C:\Users\eduard\Documents\github\Harbor\crates\cli\src\main.rs:
    1|       |use anyhow::Result;
    2|       |use clap::{Parser, Subcommand};
    3|       |use std::path::PathBuf;
    4|       |#[cfg(windows)]
    5|       |use winreg::enums::HKEY_CURRENT_USER;
    6|       |#[cfg(windows)]
    7|       |use winreg::RegKey;
    8|       |
    9|       |#[derive(Parser)]
   10|       |#[command(name = "harbor")]
   11|       |#[command(version = env!("CARGO_PKG_VERSION"))]
   12|       |struct Cli {
   13|       |    #[command(subcommand)]
   14|       |    command: Commands,
   15|       |}
   16|       |
   17|       |#[derive(Subcommand)]
   18|       |enum Commands {
   19|       |    DownloadsInit {
   20|       |        #[arg(default_value = "harbor.downloads.yaml")]
   21|       |        path: String,
   22|       |    },
   23|       |    DownloadsOrganize {
   24|       |        #[arg(default_value = "harbor.downloads.yaml")]
   25|       |        path: String,
   26|       |    },
   27|       |    DownloadsWatch {
   28|       |        #[arg(default_value = "harbor.downloads.yaml")]
   29|       |        path: String,
   30|       |        #[arg(default_value_t = 5)]
   31|       |        interval_secs: u64,
   32|       |    },
   33|       |    Validate {
   34|       |        #[arg(default_value = "harbor.config.yaml")]
   35|       |        path: String,
   36|       |    },
   37|       |    Init {
   38|       |        #[arg(default_value = "harbor.config.yaml")]
   39|       |        path: String,
   40|       |    },
   41|       |    Up {
   42|       |        #[arg(default_value = "harbor.config.yaml")]
   43|       |        path: String,
   44|       |        #[arg(default_value = ".")]
   45|       |        base_dir: String,
   46|       |        #[arg(default_value = "harbor_state.json")]
   47|       |        state_path: String,
   48|       |    },
   49|       |    Down {
   50|       |        #[arg(default_value = "harbor_state.json")]
   51|       |        state_path: String,
   52|       |    },
   53|       |    Status {
   54|       |        #[arg(default_value = "harbor_state.json")]
   55|       |        state_path: String,
   56|       |    },
   57|       |    Logs {
   58|       |        service: String,
   59|       |        #[arg(default_value = "logs")]
   60|       |        logs_dir: String,
   61|       |        #[arg(default_value = "stdout")]
   62|       |        stream: String,
   63|       |    },
   64|       |    TrayInstall {
   65|       |        #[arg(long)]
   66|       |        source: Option<String>,
   67|       |    },
   68|       |    TrayUninstall,
   69|       |}
   70|       |
   71|      0|fn main() -> Result<()> {
   72|      0|    let cli = Cli::parse();
   73|      0|    execute_command(cli.command, None)
   74|      0|}
   75|       |
   76|     10|fn execute_command(
   77|     10|    command: Commands,
   78|     10|    shutdown_signal: Option<std::sync::Arc<std::sync::atomic::AtomicBool>>,
   79|     10|) -> Result<()> {
   80|     10|    match command {
   81|      1|        Commands::DownloadsInit { path } => {
   82|      1|            init_downloads_config(&path)?;
                                                      ^0
   83|      1|            Ok(())
   84|       |        }
   85|      1|        Commands::DownloadsOrganize { path } => {
   86|      1|            let cfg = harbor_core::downloads::load_downloads_config(&path)?;
                                                                                        ^0
   87|      1|            let actions = harbor_core::downloads::organize_once(&cfg)?;
                                                                                   ^0
   88|      2|            for (from, to, rule, symlink_info) in actions {
                               ^1    ^1  ^1    ^1
   89|      1|                let sym = symlink_info.unwrap_or_default();
   90|      1|                println!("{} -> {} ({}) {}", from.display(), to.display(), rule, sym);
   91|      1|            }
   92|      1|            Ok(())
   93|       |        }
   94|       |        Commands::DownloadsWatch {
   95|      1|            path,
   96|      1|            interval_secs,
   97|       |        } => {
   98|      1|            let cfg = harbor_core::downloads::load_downloads_config(&path)?;
                                                                                        ^0
   99|      1|            let should_continue = shutdown_signal
  100|      1|                .unwrap_or_else(|| std::sync::Arc::new(std::sync::atomic::AtomicBool::new(true)));
                                                 ^0                  ^0
  101|      1|            harbor_core::downloads::watch_polling(
  102|      1|                &cfg,
  103|      1|                interval_secs,
  104|      1|                &should_continue,
  105|      0|                |actions| {
  106|      0|                    for (from, to, rule, symlink_info) in actions {
  107|      0|                        let sym = symlink_info.as_deref().unwrap_or_default();
  108|      0|                        println!("{} -> {} ({}) {}", from.display(), to.display(), rule, sym);
  109|      0|                    }
  110|      0|                },
  111|      0|            )?;
  112|      1|            Ok(())
  113|       |        }
  114|      2|        Commands::Validate { path } => {
  115|      2|            let cfg = harbor_core::config::load_config(&path)?;
                              ^1                                           ^1
  116|      1|            harbor_core::config::validate_config(&cfg)?;
                                                                    ^0
  117|      1|            println!("valid");
  118|      1|            Ok(())
  119|       |        }
  120|      1|        Commands::Init { path } => init_config(&path),
  121|       |        Commands::Up {
  122|      1|            path,
  123|      1|            base_dir,
  124|      1|            state_path,
  125|       |        } => {
  126|      1|            let cfg = harbor_core::config::load_config(&path)?;
                                                                           ^0
  127|      1|            harbor_core::config::validate_config(&cfg)?;
                                                                    ^0
  128|      1|            let st = harbor_core::orchestrator::up(
  129|      1|                &cfg,
  130|      1|                PathBuf::from(base_dir),
  131|      1|                PathBuf::from(state_path),
  132|      0|            )?;
  133|      1|            println!("{}", serde_json::to_string_pretty(&st)?);
                                                                          ^0
  134|      1|            Ok(())
  135|       |        }
  136|      1|        Commands::Down { state_path } => {
  137|      1|            harbor_core::orchestrator::down(PathBuf::from(state_path))?;
                                                                                    ^0
  138|      1|            println!("down");
  139|      1|            Ok(())
  140|       |        }
  141|      1|        Commands::Status { state_path } => {
  142|      1|            let st = harbor_core::orchestrator::status(PathBuf::from(state_path))?;
                                                                                               ^0
  143|      2|            for (name, pid, alive) in st {
                               ^1    ^1   ^1
  144|      1|                println!("{} {} {}", name, pid, if alive { "alive" } else { "dead" });
                                                                                          ^0
  145|       |            }
  146|      1|            Ok(())
  147|       |        }
  148|       |        Commands::Logs {
  149|      1|            service,
  150|      1|            logs_dir,
  151|      1|            stream,
  152|       |        } => {
  153|      1|            let path = match stream.as_str() {
  154|      1|                "stdout" => PathBuf::from(format!("{}/{}.out.log", logs_dir, service)),
  155|      0|                "stderr" => PathBuf::from(format!("{}/{}.err.log", logs_dir, service)),
  156|      0|                _ => PathBuf::from(format!("{}/{}.out.log", logs_dir, service)),
  157|       |            };
  158|      1|            let content = std::fs::read_to_string(path)?;
                                                                     ^0
  159|      1|            println!("{}", content);
  160|      1|            Ok(())
  161|       |        }
  162|      0|        Commands::TrayInstall { source } => tray_install(source, None),
  163|      0|        Commands::TrayUninstall => tray_uninstall(None),
  164|       |    }
  165|     10|}
  166|       |
  167|      1|fn init_config(path: &str) -> Result<()> {
  168|      1|    let sample = r#"services:
  169|      1|  - name: web
  170|      1|    command: "node server.js"
  171|      1|    cwd: "."
  172|      1|    depends_on: []
  173|      1|    health_check:
  174|      1|      kind: http
  175|      1|      url: "http://localhost:3000/health"
  176|      1|      timeout_ms: 5000
  177|      1|      retries: 10
  178|      1|"#;
  179|      1|    std::fs::write(path, sample)?;
                                              ^0
  180|      1|    println!("created {}", path);
  181|      1|    Ok(())
  182|      1|}
  183|       |
  184|       |#[cfg(windows)]
  185|      1|fn tray_install(source: Option<String>, registry_path: Option<&str>) -> Result<()> {
  186|      1|    let src = if let Some(s) = source {
                                        ^0
  187|      0|        PathBuf::from(s)
  188|       |    } else {
  189|       |        // Try to find it next to the CLI executable first
  190|      1|        let mut p = std::env::current_exe()
  191|      1|            .ok()
  192|      1|            .and_then(|path| path.parent().map(|d| d.join("harbor-tray.exe")))
  193|      1|            .unwrap_or_else(|| PathBuf::from("harbor-tray.exe"));
                                             ^0
  194|       |
  195|      1|        if !p.exists() {
  196|      1|            // Fallback to dev path
  197|      1|            p = PathBuf::from("target/release/harbor-tray.exe");
  198|      1|        }
                      ^0
  199|      1|        p
  200|       |    };
  201|       |
  202|       |    // In tests (when registry_path is provided), we skip the existence check if source is implicit,
  203|       |    // or we check strictly if explicit.
  204|      1|    let is_test = registry_path.is_some();
  205|      1|    if !src.exists() && !is_test {
  206|      0|        anyhow::bail!("source not found: {}", src.display());
  207|      1|    }
  208|       |
  209|      1|    let install_dir = std::env::var("LOCALAPPDATA")
  210|      1|        .map(|p| PathBuf::from(p).join("Harbor"))
  211|      1|        .unwrap_or(PathBuf::from("C:\\Harbor"));
  212|       |
  213|      1|    if !is_test {
  214|      0|        std::fs::create_dir_all(&install_dir)?;
  215|      0|        let dest = install_dir.join("harbor-tray.exe");
  216|      0|        std::fs::copy(&src, &dest)?;
  217|       |
  218|       |        // Copy icons...
  219|      0|        let exe_dir = std::env::current_exe()
  220|      0|            .ok()
  221|      0|            .and_then(|p| p.parent().map(|d| d.to_path_buf()));
  222|      0|        for name in ["icon_h.ico", "harbor-tray.ico", "harbor.ico"] {
  223|      0|            if let Some(d) = &exe_dir {
  224|      0|                let p = d.join(name);
  225|      0|                if p.exists() {
  226|      0|                    let _ = std::fs::copy(&p, install_dir.join(name));
  227|      0|                    continue;
  228|      0|                }
  229|      0|            }
  230|      0|            let p = PathBuf::from(format!("assets/{}", name));
  231|      0|            if p.exists() {
  232|      0|                let _ = std::fs::copy(&p, install_dir.join(name));
  233|      0|            }
  234|       |        }
  235|      1|    }
  236|       |
  237|      1|    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  238|      1|    let run_key = registry_path.unwrap_or("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
  239|       |
  240|       |    // Ensure key exists for tests
  241|      1|    let (key, _) = hkcu.create_subkey(run_key)?;
                                                            ^0
  242|       |
  243|      1|    let val = format!("\"{}\"", install_dir.join("harbor-tray.exe").display());
  244|      1|    key.set_value("HarborTray", &val)?;
                                                   ^0
  245|       |
  246|      1|    println!(
  247|      1|        "installed {}",
  248|      1|        install_dir.join("harbor-tray.exe").display()
  249|       |    );
  250|      1|    Ok(())
  251|      1|}
  252|       |
  253|       |#[cfg(not(windows))]
  254|       |fn tray_install(_source: Option<String>, _registry_path: Option<&str>) -> Result<()> {
  255|       |    anyhow::bail!("windows only");
  256|       |}
  257|       |
  258|       |#[cfg(windows)]
  259|      1|fn tray_uninstall(registry_path: Option<&str>) -> Result<()> {
  260|      1|    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  261|      1|    let run_key = registry_path.unwrap_or("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
  262|       |
  263|      1|    if let Ok(key) = hkcu.open_subkey_with_flags(run_key, winreg::enums::KEY_WRITE) {
  264|      1|        let _ = key.delete_value("HarborTray");
  265|      1|    }
                  ^0
  266|      1|    println!("uninstalled");
  267|      1|    Ok(())
  268|      1|}
  269|       |
  270|       |#[cfg(not(windows))]
  271|       |fn tray_uninstall(_registry_path: Option<&str>) -> Result<()> {
  272|       |    anyhow::bail!("windows only");
  273|       |}
  274|       |
  275|      1|fn init_downloads_config(path: &str) -> Result<()> {
  276|      1|    let sample = r#"download_dir: "C:\\Users\\%USERNAME%\\Downloads"
  277|      1|min_age_secs: 5
  278|      1|rules:
  279|      1|  - name: images
  280|      1|    extensions: ["jpg", "jpeg", "png", "gif", "webp"]
  281|      1|    target_dir: "C:\\Users\\%USERNAME%\\Downloads\\Images"
  282|      1|  - name: videos
  283|      1|    extensions: ["mp4", "mov", "mkv", "avi"]
  284|      1|    target_dir: "C:\\Users\\%USERNAME%\\Downloads\\Videos"
  285|      1|  - name: archives
  286|      1|    extensions: ["zip", "rar", "7z", "tar", "gz"]
  287|      1|    target_dir: "C:\\Users\\%USERNAME%\\Downloads\\Archives"
  288|      1|  - name: docs
  289|      1|    extensions: ["pdf", "docx", "xlsx", "pptx", "txt"]
  290|      1|    target_dir: "C:\\Users\\%USERNAME%\\Downloads\\Documents"
  291|      1|  - name: installers
  292|      1|    extensions: ["exe", "msi"]
  293|      1|    target_dir: "C:\\Users\\%USERNAME%\\Downloads\\Installers"
  294|      1|"#;
  295|      1|    std::fs::write(path, sample)?;
                                              ^0
  296|      1|    println!("created {}", path);
  297|      1|    Ok(())
  298|      1|}
  299|       |
  300|       |#[cfg(test)]
  301|       |mod tests {
  302|       |    use super::*;
  303|       |    use std::io::Write;
  304|       |    use std::sync::atomic::AtomicBool;
  305|       |    use std::sync::Arc;
  306|       |    use tempfile::NamedTempFile;
  307|       |
  308|       |    #[test]
  309|      1|    fn test_init_config() {
  310|      1|        let file = NamedTempFile::new().unwrap();
  311|      1|        let path = file.path().to_str().unwrap();
  312|      1|        execute_command(
  313|      1|            Commands::Init {
  314|      1|                path: path.to_string(),
  315|      1|            },
  316|      1|            None,
  317|       |        )
  318|      1|        .unwrap();
  319|      1|        let content = std::fs::read_to_string(path).unwrap();
  320|      1|        assert!(content.contains("services:"));
  321|      1|        assert!(content.contains("health_check:"));
  322|      1|    }
  323|       |
  324|       |    #[test]
  325|      1|    fn test_init_downloads_config() {
  326|      1|        let file = NamedTempFile::new().unwrap();
  327|      1|        let path = file.path().to_str().unwrap();
  328|      1|        execute_command(
  329|      1|            Commands::DownloadsInit {
  330|      1|                path: path.to_string(),
  331|      1|            },
  332|      1|            None,
  333|       |        )
  334|      1|        .unwrap();
  335|      1|        let content = std::fs::read_to_string(path).unwrap();
  336|      1|        assert!(content.contains("download_dir:"));
  337|      1|        assert!(content.contains("rules:"));
  338|      1|    }
  339|       |
  340|       |    #[test]
  341|      1|    fn test_validate_valid() {
  342|      1|        let mut file = tempfile::Builder::new().suffix(".yaml").tempfile().unwrap();
  343|      1|        writeln!(file, "services: []").unwrap();
  344|      1|        let path = file.path().to_str().unwrap().to_string();
  345|      1|        assert!(execute_command(Commands::Validate { path }, None).is_ok());
  346|      1|    }
  347|       |
  348|       |    #[test]
  349|      1|    fn test_validate_invalid() {
  350|      1|        let mut file = tempfile::Builder::new().suffix(".yaml").tempfile().unwrap();
  351|      1|        writeln!(file, "invalid").unwrap();
  352|      1|        let path = file.path().to_str().unwrap().to_string();
  353|      1|        assert!(execute_command(Commands::Validate { path }, None).is_err());
  354|      1|    }
  355|       |
  356|       |    #[test]
  357|      1|    fn test_downloads_organize() {
  358|      1|        let temp = tempfile::TempDir::new().unwrap();
  359|      1|        let dl_dir = temp.path().join("DL");
  360|      1|        std::fs::create_dir(&dl_dir).unwrap();
  361|      1|        let cfg_path = temp.path().join("config.yaml");
  362|       |
  363|       |        // Create config with simple rule
  364|      1|        let cfg_content = format!(
  365|      1|            r#"
  366|      1|download_dir: "{}"
  367|      1|min_age_secs: 0
  368|      1|rules:
  369|      1|  - name: test
  370|      1|    extensions: ["txt"]
  371|      1|    target_dir: "{}"
  372|      1|"#,
  373|      1|            dl_dir.display().to_string().replace("\\", "\\\\"),
  374|      1|            temp.path()
  375|      1|                .join("Target")
  376|      1|                .display()
  377|      1|                .to_string()
  378|      1|                .replace("\\", "\\\\")
  379|       |        );
  380|      1|        std::fs::write(&cfg_path, cfg_content).unwrap();
  381|       |
  382|       |        // Create file
  383|      1|        std::fs::write(dl_dir.join("test.txt"), "content").unwrap();
  384|       |
  385|      1|        assert!(execute_command(
  386|      1|            Commands::DownloadsOrganize {
  387|      1|                path: cfg_path.to_str().unwrap().to_string()
  388|      1|            },
  389|      1|            None
  390|      1|        )
  391|      1|        .is_ok());
  392|       |
  393|      1|        assert!(temp.path().join("Target").join("test.txt").exists());
  394|      1|    }
  395|       |
  396|       |    #[test]
  397|      1|    fn test_downloads_watch() {
  398|      1|        let temp = tempfile::TempDir::new().unwrap();
  399|      1|        let dl_dir = temp.path().join("DL");
  400|      1|        std::fs::create_dir(&dl_dir).unwrap();
  401|      1|        let cfg_path = temp.path().join("config.yaml");
  402|      1|        std::fs::write(
  403|      1|            &cfg_path,
  404|      1|            format!(
  405|      1|                "download_dir: \"{}\"\nrules: []",
  406|      1|                dl_dir.display().to_string().replace("\\", "\\\\")
  407|       |            ),
  408|       |        )
  409|      1|        .unwrap();
  410|       |
  411|      1|        let signal = Arc::new(AtomicBool::new(false)); // Stop immediately
  412|      1|        assert!(execute_command(
  413|      1|            Commands::DownloadsWatch {
  414|      1|                path: cfg_path.to_str().unwrap().to_string(),
  415|      1|                interval_secs: 1
  416|      1|            },
  417|      1|            Some(signal)
  418|      1|        )
  419|      1|        .is_ok());
  420|      1|    }
  421|       |
  422|       |    #[test]
  423|      1|    fn test_up_down_status_logs() {
  424|      1|        let temp = tempfile::TempDir::new().unwrap();
  425|      1|        let base_dir = temp.path().join("base");
  426|      1|        let state_path = temp.path().join("state.json");
  427|      1|        std::fs::create_dir(&base_dir).unwrap();
  428|       |
  429|      1|        let cfg_path = temp.path().join("config.yaml");
  430|       |        // Use a command that exits successfully quickly or stays running
  431|       |        // For 'Up', we want it to stay running briefly, or just launch.
  432|       |        // Echo is fine, but it exits immediately.
  433|       |        // If it exits immediately, 'Status' might show 'dead'.
  434|      1|        let cmd = if cfg!(windows) {
  435|      1|            "ping -n 2 127.0.0.1"
  436|       |        } else {
  437|      0|            "sleep 1"
  438|       |        };
  439|       |
  440|      1|        let cfg_content = format!(
  441|      1|            r#"
  442|      1|services:
  443|      1|  - name: test_svc
  444|      1|    command: "{}"
  445|      1|"#,
  446|       |            cmd
  447|       |        );
  448|      1|        std::fs::write(&cfg_path, cfg_content).unwrap();
  449|       |
  450|       |        // 1. Up
  451|      1|        assert!(execute_command(
  452|      1|            Commands::Up {
  453|      1|                path: cfg_path.to_str().unwrap().to_string(),
  454|      1|                base_dir: base_dir.to_str().unwrap().to_string(),
  455|      1|                state_path: state_path.to_str().unwrap().to_string(),
  456|      1|            },
  457|      1|            None
  458|      1|        )
  459|      1|        .is_ok());
  460|       |
  461|       |        // 2. Status
  462|      1|        assert!(execute_command(
  463|      1|            Commands::Status {
  464|      1|                state_path: state_path.to_str().unwrap().to_string(),
  465|      1|            },
  466|      1|            None
  467|      1|        )
  468|      1|        .is_ok());
  469|       |
  470|       |        // 3. App should have created logs
  471|      1|        let logs_dir = base_dir.join("logs");
  472|      1|        assert!(logs_dir.exists());
  473|       |
  474|       |        // Logs command
  475|      1|        assert!(execute_command(
  476|      1|            Commands::Logs {
  477|      1|                service: "test_svc".to_string(),
  478|      1|                logs_dir: logs_dir.to_str().unwrap().to_string(),
  479|      1|                stream: "stdout".to_string()
  480|      1|            },
  481|      1|            None
  482|      1|        )
  483|      1|        .is_ok());
  484|       |
  485|       |        // 4. Down
  486|      1|        assert!(execute_command(
  487|      1|            Commands::Down {
  488|      1|                state_path: state_path.to_str().unwrap().to_string(),
  489|      1|            },
  490|      1|            None
  491|      1|        )
  492|      1|        .is_ok());
  493|      1|    }
  494|       |
  495|       |    #[cfg(windows)]
  496|       |    #[test]
  497|      1|    fn test_tray_install_uninstall() {
  498|      1|        let test_reg_path = "Software\\HarborTest";
  499|       |        // Install
  500|      1|        assert!(tray_install(None, Some(test_reg_path)).is_ok());
  501|       |
  502|      1|        let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  503|      1|        let key = hkcu.open_subkey(test_reg_path).unwrap();
  504|      1|        let val: String = key.get_value("HarborTray").unwrap();
  505|      1|        assert!(val.contains("harbor-tray.exe"));
  506|       |
  507|       |        // Uninstall
  508|      1|        assert!(tray_uninstall(Some(test_reg_path)).is_ok());
  509|      1|        let val: Result<String, _> = key.get_value("HarborTray");
  510|      1|        assert!(val.is_err());
  511|       |
  512|       |        // Cleanup
  513|      1|        let _ = hkcu.delete_subkey(test_reg_path);
  514|      1|    }
  515|       |}

C:\Users\eduard\Documents\github\Harbor\crates\core\src\config.rs:
    1|       |use crate::types::WorkspaceConfig;
    2|       |use anyhow::{bail, Context, Result};
    3|       |use std::collections::HashSet;
    4|       |use std::fs;
    5|       |use std::path::Path;
    6|       |
    7|      9|pub fn load_config(path: impl AsRef<Path>) -> Result<WorkspaceConfig> {
    8|      9|    let p = path.as_ref();
    9|      9|    let content = fs::read_to_string(p).with_context(|| format!("read {}", p.display()))?;
                      ^8                                              ^1      ^1         ^1^1         ^1
   10|      8|    let ext = p
   11|      8|        .extension()
   12|      8|        .and_then(|s| s.to_str())
                                    ^6^6
   13|      8|        .unwrap_or("")
   14|      8|        .to_ascii_lowercase();
   15|      8|    match ext.as_str() {
   16|      8|        "yaml" | "yml" => {
                               ^3
   17|      5|            let cfg: WorkspaceConfig = serde_yaml::from_str(&content).context("parse yaml")?;
                              ^3   ^3                                                                    ^2
   18|      3|            Ok(cfg)
   19|       |        }
   20|      3|        "json" => {
   21|      1|            let cfg: WorkspaceConfig = serde_json::from_str(&content).context("parse json")?;
                                                                                                         ^0
   22|      1|            Ok(cfg)
   23|       |        }
   24|       |        _ => {
   25|      2|            let yaml = serde_yaml::from_str::<WorkspaceConfig>(&content);
   26|      2|            if let Ok(cfg) = yaml {
   27|      2|                return Ok(cfg);
   28|      0|            }
   29|      0|            let json = serde_json::from_str::<WorkspaceConfig>(&content);
   30|      0|            if let Ok(cfg) = json {
   31|      0|                return Ok(cfg);
   32|      0|            }
   33|      0|            bail!("unsupported config format");
   34|       |        }
   35|       |    }
   36|      9|}
   37|       |
   38|      5|pub fn validate_config(cfg: &WorkspaceConfig) -> Result<()> {
   39|      5|    let mut names = HashSet::new();
   40|     10|    for s in &cfg.services {
                      ^6
   41|      6|        if !names.insert(&s.name) {
   42|      1|            bail!("duplicate service name {}", s.name);
   43|      5|        }
   44|       |    }
   45|      4|    Ok(())
   46|      5|}
   47|       |
   48|       |#[cfg(test)]
   49|       |mod tests {
   50|       |    use super::*;
   51|       |    use crate::types::Service;
   52|       |    use std::io::Write;
   53|       |    use tempfile::NamedTempFile;
   54|       |
   55|       |    #[test]
   56|      1|    fn test_load_config_yaml_ext() {
   57|      1|        let mut file = tempfile::Builder::new().suffix(".yaml").tempfile().unwrap();
   58|      1|        writeln!(
   59|      1|            file,
   60|      1|            r#"
   61|      1|services:
   62|      1|  - name: test
   63|      1|    command: echo hello
   64|      1|"#
   65|       |        )
   66|      1|        .unwrap();
   67|       |
   68|      1|        let cfg = load_config(file.path()).unwrap();
   69|      1|        assert_eq!(cfg.services.len(), 1);
   70|      1|        assert_eq!(cfg.services[0].name, "test");
   71|      1|    }
   72|       |
   73|       |    #[test]
   74|      1|    fn test_load_config_json_ext() {
   75|      1|        let mut file = tempfile::Builder::new().suffix(".json").tempfile().unwrap();
   76|      1|        writeln!(
   77|      1|            file,
   78|      1|            r#"
   79|      1|{{
   80|      1|  "services": [
   81|      1|    {{
   82|      1|      "name": "test",
   83|      1|      "command": "echo hello"
   84|      1|    }}
   85|      1|  ]
   86|      1|}}
   87|      1|"#
   88|       |        )
   89|      1|        .unwrap();
   90|       |
   91|      1|        let cfg = load_config(file.path()).unwrap();
   92|      1|        assert_eq!(cfg.services.len(), 1);
   93|      1|        assert_eq!(cfg.services[0].name, "test");
   94|      1|    }
   95|       |
   96|       |    #[test]
   97|      1|    fn test_load_config_unknown_ext_yaml() {
   98|      1|        let mut file = NamedTempFile::new().unwrap();
   99|      1|        writeln!(
  100|      1|            file,
  101|      1|            r#"
  102|      1|services:
  103|      1|  - name: test
  104|      1|    command: echo hello
  105|      1|"#
  106|       |        )
  107|      1|        .unwrap();
  108|       |
  109|      1|        let cfg = load_config(file.path()).unwrap();
  110|      1|        assert_eq!(cfg.services.len(), 1);
  111|      1|    }
  112|       |
  113|       |    #[test]
  114|      1|    fn test_load_config_unknown_ext_json() {
  115|      1|        let mut file = NamedTempFile::new().unwrap();
  116|      1|        writeln!(
  117|      1|            file,
  118|      1|            r#"
  119|      1|{{
  120|      1|  "services": [
  121|      1|    {{
  122|      1|        "name": "test",
  123|      1|        "command": "echo hello"
  124|      1|    }}
  125|      1|  ]
  126|      1|}}
  127|      1|"#
  128|       |        )
  129|      1|        .unwrap();
  130|       |
  131|      1|        let cfg = load_config(file.path()).unwrap();
  132|      1|        assert_eq!(cfg.services.len(), 1);
  133|      1|    }
  134|       |
  135|       |    #[test]
  136|      1|    fn test_load_config_fail_parse() {
  137|      1|        let mut file = tempfile::Builder::new().suffix(".yaml").tempfile().unwrap();
  138|      1|        writeln!(file, "invalid yaml").unwrap();
  139|      1|        let res = load_config(file.path());
  140|      1|        assert!(res.is_err());
  141|      1|    }
  142|       |
  143|       |    #[test]
  144|      1|    fn test_load_config_fail_read() {
  145|      1|        let res = load_config(Path::new("non_existent_file.yaml"));
  146|      1|        assert!(res.is_err());
  147|      1|    }
  148|       |
  149|       |    #[test]
  150|      1|    fn test_validate_config_duplicate() {
  151|      1|        let s = Service {
  152|      1|            name: "s1".to_string(),
  153|      1|            command: "cmd".to_string(),
  154|      1|            cwd: None,
  155|      1|            env: None,
  156|      1|            depends_on: None,
  157|      1|            health_check: None,
  158|      1|        };
  159|      1|        let cfg = WorkspaceConfig {
  160|      1|            services: vec![s.clone(), s.clone()],
  161|      1|        };
  162|      1|        let res = validate_config(&cfg);
  163|      1|        assert!(res.is_err());
  164|      1|        assert!(res.unwrap_err().to_string().contains("duplicate service"));
  165|      1|    }
  166|       |
  167|       |    #[test]
  168|      1|    fn test_validate_config_ok() {
  169|      1|        let s1 = Service {
  170|      1|            name: "s1".to_string(),
  171|      1|            command: "cmd".to_string(),
  172|      1|            cwd: None,
  173|      1|            env: None,
  174|      1|            depends_on: None,
  175|      1|            health_check: None,
  176|      1|        };
  177|      1|        let s2 = Service {
  178|      1|            name: "s2".to_string(),
  179|      1|            command: "cmd".to_string(),
  180|      1|            cwd: None,
  181|      1|            env: None,
  182|      1|            depends_on: None,
  183|      1|            health_check: None,
  184|      1|        };
  185|      1|        let cfg = WorkspaceConfig {
  186|      1|            services: vec![s1, s2],
  187|      1|        };
  188|      1|        let res = validate_config(&cfg);
  189|      1|        assert!(res.is_ok());
  190|      1|    }
  191|       |}

C:\Users\eduard\Documents\github\Harbor\crates\core\src\downloads.rs:
    1|       |use crate::types::Rule;
    2|       |use anyhow::{Context, Result};
    3|       |
    4|       |use regex::Regex;
    5|       |use serde::{Deserialize, Serialize};
    6|       |use std::fs;
    7|       |#[cfg(windows)]
    8|       |use std::os::windows::process::CommandExt;
    9|       |use std::path::{Path, PathBuf};
   10|       |use std::thread;
   11|       |use std::time::{Duration, SystemTime};
   12|       |
   13|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   14|       |pub struct DownloadsConfig {
   15|       |    pub download_dir: String,
   16|       |    pub rules: Vec<Rule>,
   17|       |    pub min_age_secs: Option<u64>,
   18|       |    pub tutorial_completed: Option<bool>,
   19|       |    pub service_enabled: Option<bool>,
   20|       |}
   21|       |
   22|       |pub type OrganizeResult = (PathBuf, PathBuf, String, Option<String>);
   23|       |
   24|       |/// Loads and parses the downloads configuration file.
   25|       |///
   26|       |/// This function reads a YAML file from the specified path, parses it into a
   27|       |/// `DownloadsConfig` struct, and expands environment variables (like `%USERPROFILE%`)
   28|       |/// in the paths.
   29|       |///
   30|       |/// # Arguments
   31|       |///
   32|       |/// * `path` - Path to the configuration file
   33|       |///
   34|       |/// # Examples
   35|       |///
   36|       |/// ```no_run
   37|       |/// use harbor_core::downloads::load_downloads_config;
   38|       |///
   39|       |/// if let Ok(cfg) = load_downloads_config("harbor.downloads.yaml") {
   40|       |///     println!("Monitoring {}", cfg.download_dir);
   41|       |/// }
   42|       |/// ```
   43|      2|pub fn default_config() -> DownloadsConfig {
   44|      2|    let user = std::env::var("USERPROFILE").unwrap_or_else(|_| "C:\\Users\\Public".to_string());
                                                                             ^0                  ^0
   45|      2|    let dl = format!("{}\\Downloads", user);
   46|      2|    let pictures = format!("{}\\Downloads\\Images", user);
   47|      2|    let videos = format!("{}\\Downloads\\Videos", user);
   48|      2|    let music = format!("{}\\Downloads\\Music", user);
   49|      2|    let docs = format!("{}\\Downloads\\Documents", user);
   50|      2|    let archives = format!("{}\\Downloads\\Archives", user);
   51|      2|    let installers = format!("{}\\Downloads\\Installers", user);
   52|      2|    let torrents = format!("{}\\Downloads\\Torrents", user);
   53|      2|    let isos = format!("{}\\Downloads\\ISOs", user);
   54|      2|    let dev = format!("{}\\Downloads\\Dev", user);
   55|      2|    let subtitles = format!("{}\\Downloads\\Subtitles", user);
   56|      2|    let webpages = format!("{}\\Downloads\\Webpages", user);
   57|       |
   58|       |    DownloadsConfig {
   59|      2|        download_dir: dl,
   60|      2|        min_age_secs: Some(5),
   61|      2|        tutorial_completed: Some(false),
   62|      2|        service_enabled: Some(true),
   63|      2|        rules: vec![
   64|       |            Rule {
   65|      2|                name: "Images".to_string(),
   66|       |                extensions: Some(
   67|      2|                    [
   68|      2|                        "jpg", "jpeg", "png", "gif", "bmp", "webp", "tiff", "heic", "svg", "avif",
   69|      2|                    ]
   70|      2|                    .iter()
   71|     20|                    .map(|s| s.to_string())
                                   ^2
   72|      2|                    .collect(),
   73|       |                ),
   74|      2|                pattern: None,
   75|      2|                min_size_bytes: None,
   76|      2|                max_size_bytes: None,
   77|      2|                target_dir: pictures,
   78|      2|                create_symlink: None,
   79|      2|                enabled: Some(true),
   80|       |            },
   81|       |            Rule {
   82|      2|                name: "Videos".to_string(),
   83|       |                extensions: Some(
   84|      2|                    ["mp4", "mkv", "avi", "mov", "wmv", "webm"]
   85|      2|                        .iter()
   86|     12|                        .map(|s| s.to_string())
                                       ^2
   87|      2|                        .collect(),
   88|       |                ),
   89|      2|                pattern: None,
   90|      2|                min_size_bytes: None,
   91|      2|                max_size_bytes: None,
   92|      2|                target_dir: videos,
   93|      2|                create_symlink: None,
   94|      2|                enabled: Some(true),
   95|       |            },
   96|       |            Rule {
   97|      2|                name: "Music".to_string(),
   98|       |                extensions: Some(
   99|      2|                    ["mp3", "flac", "wav", "aac", "ogg"]
  100|      2|                        .iter()
  101|     10|                        .map(|s| s.to_string())
                                       ^2
  102|      2|                        .collect(),
  103|       |                ),
  104|      2|                pattern: None,
  105|      2|                min_size_bytes: None,
  106|      2|                max_size_bytes: None,
  107|      2|                target_dir: music,
  108|      2|                create_symlink: None,
  109|      2|                enabled: Some(true),
  110|       |            },
  111|       |            Rule {
  112|      2|                name: "Archives".to_string(),
  113|       |                extensions: Some(
  114|      2|                    ["zip", "rar", "7z", "tar", "gz", "xz"]
  115|      2|                        .iter()
  116|     12|                        .map(|s| s.to_string())
                                       ^2
  117|      2|                        .collect(),
  118|       |                ),
  119|      2|                pattern: None,
  120|      2|                min_size_bytes: None,
  121|      2|                max_size_bytes: None,
  122|      2|                target_dir: archives,
  123|      2|                create_symlink: None,
  124|      2|                enabled: Some(true),
  125|       |            },
  126|       |            Rule {
  127|      2|                name: "Documents".to_string(),
  128|       |                extensions: Some(
  129|      2|                    [
  130|      2|                        "pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "txt", "rtf",
  131|      2|                    ]
  132|      2|                    .iter()
  133|     18|                    .map(|s| s.to_string())
                                   ^2
  134|      2|                    .collect(),
  135|       |                ),
  136|      2|                pattern: None,
  137|      2|                min_size_bytes: None,
  138|      2|                max_size_bytes: None,
  139|      2|                target_dir: docs.clone(),
  140|      2|                create_symlink: None,
  141|      2|                enabled: Some(true),
  142|       |            },
  143|       |            Rule {
  144|      2|                name: "Installers".to_string(),
  145|       |                extensions: Some(
  146|      2|                    ["exe", "msi", "msix", "dmg", "pkg", "apk"]
  147|      2|                        .iter()
  148|     12|                        .map(|s| s.to_string())
                                       ^2
  149|      2|                        .collect(),
  150|       |                ),
  151|      2|                pattern: None,
  152|      2|                min_size_bytes: None,
  153|      2|                max_size_bytes: None,
  154|      2|                target_dir: installers,
  155|      2|                create_symlink: None,
  156|      2|                enabled: Some(true),
  157|       |            },
  158|       |            Rule {
  159|      2|                name: "ISOs".to_string(),
  160|      2|                extensions: Some(["iso"].iter().map(|s| s.to_string()).collect()),
  161|      2|                pattern: None,
  162|      2|                min_size_bytes: None,
  163|      2|                max_size_bytes: None,
  164|      2|                target_dir: isos,
  165|      2|                create_symlink: None,
  166|      2|                enabled: Some(true),
  167|       |            },
  168|       |            Rule {
  169|      2|                name: "Torrents".to_string(),
  170|      2|                extensions: Some(["torrent"].iter().map(|s| s.to_string()).collect()),
  171|      2|                pattern: None,
  172|      2|                min_size_bytes: None,
  173|      2|                max_size_bytes: None,
  174|      2|                target_dir: torrents,
  175|      2|                create_symlink: None,
  176|      2|                enabled: Some(true),
  177|       |            },
  178|       |            Rule {
  179|      2|                name: "Dev".to_string(),
  180|       |                extensions: Some(
  181|      2|                    ["json", "env", "xml", "plist"]
  182|      2|                        .iter()
  183|      8|                        .map(|s| s.to_string())
                                       ^2
  184|      2|                        .collect(),
  185|       |                ),
  186|      2|                pattern: None,
  187|      2|                min_size_bytes: None,
  188|      2|                max_size_bytes: None,
  189|      2|                target_dir: dev,
  190|      2|                create_symlink: None,
  191|      2|                enabled: Some(true),
  192|       |            },
  193|       |            Rule {
  194|      2|                name: "Web Pages".to_string(),
  195|      4|                extensions: Some(["html", "htm"].iter().map(|s| s.to_string()).collect()),
                                               ^2              ^2     ^2                     ^2
  196|      2|                pattern: None,
  197|      2|                min_size_bytes: None,
  198|      2|                max_size_bytes: None,
  199|      2|                target_dir: webpages,
  200|      2|                create_symlink: None,
  201|      2|                enabled: Some(true),
  202|       |            },
  203|       |            Rule {
  204|      2|                name: "Subtitles".to_string(),
  205|      4|                extensions: Some(["srt", "vtt"].iter().map(|s| s.to_string()).collect()),
                                               ^2             ^2     ^2                     ^2
  206|      2|                pattern: None,
  207|      2|                min_size_bytes: None,
  208|      2|                max_size_bytes: None,
  209|      2|                target_dir: subtitles,
  210|      2|                create_symlink: None,
  211|      2|                enabled: Some(true),
  212|       |            },
  213|       |        ],
  214|       |    }
  215|      2|}
  216|       |
  217|      5|pub fn load_downloads_config(path: impl AsRef<Path>) -> Result<DownloadsConfig> {
  218|      5|    let p = path.as_ref();
  219|      5|    let content = fs::read_to_string(p).with_context(|| format!("read {}", p.display()))?;
                                                                      ^0      ^0         ^0^0         ^0
  220|      5|    let mut cfg: DownloadsConfig =
  221|      5|        serde_yaml::from_str(&content).context("parse downloads yaml")?;
                                                                                    ^0
  222|      5|    cfg.download_dir = expand_env(&cfg.download_dir);
  223|      5|    for r in cfg.rules.iter_mut() {
                      ^2
  224|      2|        r.target_dir = expand_env(&r.target_dir);
  225|      2|    }
  226|      5|    Ok(cfg)
  227|      5|}
  228|       |
  229|     10|fn is_partial(name: &str) -> bool {
  230|     10|    let lower = name.to_ascii_lowercase();
  231|     10|    lower.ends_with(".crdownload")
  232|      8|        || lower.ends_with(".part")
  233|      7|        || lower.ends_with(".tmp")
  234|      6|        || lower.ends_with(".download")
  235|     10|}
  236|       |
  237|      7|fn matches_rule(path: &Path, meta: &fs::Metadata, rule: &Rule) -> bool {
  238|      7|    if let Some(exts) = &rule.extensions {
                              ^5
  239|      5|        let ext = path
  240|      5|            .extension()
  241|      5|            .and_then(|e| e.to_str())
  242|      5|            .map(|e| e.to_ascii_lowercase())
  243|      5|            .unwrap_or_default();
  244|      5|        if !exts.iter().any(|x| x.to_ascii_lowercase() == ext) {
  245|      1|            return false;
  246|      4|        }
  247|      2|    }
  248|      6|    if let Some(pat) = &rule.pattern {
                              ^1
  249|      1|        if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
  250|      1|            if let Ok(re) = Regex::new(pat) {
  251|      1|                if !re.is_match(name) {
  252|      0|                    return false;
  253|      1|                }
  254|      0|            }
  255|      0|        }
  256|      5|    }
  257|      6|    let size: u64 = meta.len();
  258|      6|    if let Some(min) = rule.min_size_bytes {
                              ^1
  259|      1|        if size < min {
  260|      0|            return false;
  261|      1|        }
  262|      5|    }
  263|      6|    if let Some(max) = rule.max_size_bytes {
                              ^1
  264|      1|        if size > max {
  265|      0|            return false;
  266|      1|        }
  267|      5|    }
  268|      6|    true
  269|      7|}
  270|       |
  271|      3|fn ensure_dir(dir: &Path) -> Result<()> {
  272|      3|    fs::create_dir_all(dir).with_context(|| format!("create {}", dir.display()))?;
                                                          ^0      ^0           ^0  ^0         ^0
  273|      3|    Ok(())
  274|      3|}
  275|       |
  276|      6|fn unique_target(target: &Path) -> PathBuf {
  277|      6|    if !target.exists() {
  278|      4|        return target.to_path_buf();
  279|      2|    }
  280|      2|    let mut i = 1u32;
  281|       |    loop {
  282|      3|        let mut p = target.to_path_buf();
  283|      3|        let stem = target
  284|      3|            .file_stem()
  285|      3|            .and_then(|s| s.to_str())
  286|      3|            .unwrap_or("file");
  287|      3|        let ext = target.extension().and_then(|e| e.to_str()).unwrap_or("");
  288|      3|        let name = if ext.is_empty() {
  289|      0|            format!("{} ({})", stem, i)
  290|       |        } else {
  291|      3|            format!("{} ({}).{}", stem, i, ext)
  292|       |        };
  293|      3|        p.set_file_name(name);
  294|      3|        if !p.exists() {
  295|      2|            return p;
  296|      1|        }
  297|      1|        i += 1;
  298|       |    }
  299|      6|}
  300|       |
  301|       |/// Runs a single organization pass based on the provided configuration.
  302|       |///
  303|       |/// Iterates through files in the `download_dir`, checks them against the defined `rules`,
  304|       |/// and moves matching files to their target directories. It also handles safe renaming
  305|       |/// (to avoid overwrites) and optional symlink creation.
  306|       |///
  307|       |/// Returns a list of actions taken, where each action is a tuple:
  308|       |/// `(original_path, new_path, rule_name, symlink_info)`.
  309|      3|pub fn organize_once(cfg: &DownloadsConfig) -> Result<Vec<OrganizeResult>> {
  310|      3|    let base = PathBuf::from(&cfg.download_dir);
  311|      3|    let min_age = Duration::from_secs(cfg.min_age_secs.unwrap_or(5));
  312|      3|    let mut actions = Vec::new();
  313|      3|    for entry in fs::read_dir(&base).with_context(|| format!("list {}", base.display()))? {
                                                                   ^0      ^0         ^0              ^0
  314|      3|        let entry = entry?;
                                       ^0
  315|      3|        let path = entry.path();
  316|      3|        let meta = match fs::symlink_metadata(&path) {
  317|      3|            Ok(m) => m,
  318|      0|            Err(_) => continue,
  319|       |        };
  320|      3|        if meta.file_type().is_symlink() || !meta.is_file() {
  321|      0|            continue;
  322|      3|        }
  323|      3|        if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
  324|      3|            if is_partial(name) {
  325|      0|                continue;
  326|      3|            }
  327|      0|        }
  328|      3|        if let Ok(modified) = meta.modified() {
  329|      3|            if SystemTime::now()
  330|      3|                .duration_since(modified)
  331|      3|                .unwrap_or(Duration::from_secs(0))
  332|      3|                < min_age
  333|       |            {
  334|      0|                continue;
  335|      3|            }
  336|      0|        }
  337|      3|        let mut applied: Option<(&Rule, PathBuf)> = None;
  338|      3|        for rule in &cfg.rules {
  339|       |            // Skip disabled rules
  340|      3|            if !rule.enabled.unwrap_or(true) {
  341|      0|                continue;
  342|      3|            }
  343|      3|            if matches_rule(&path, &meta, rule) {
  344|      3|                let target_dir = PathBuf::from(&rule.target_dir);
  345|      3|                ensure_dir(&target_dir)?;
                                                     ^0
  346|      3|                let target = target_dir.join(
  347|      3|                    path.file_name()
  348|      3|                        .map(|n| n.to_os_string())
  349|      3|                        .unwrap_or_default(),
  350|       |                );
  351|      3|                let target = unique_target(&target);
  352|      3|                applied = Some((rule, target));
  353|      3|                break;
  354|      0|            }
  355|       |        }
  356|      3|        if let Some((rule, target)) = applied {
  357|      3|            fs::rename(&path, &target)
  358|      3|                .with_context(|| format!("move {} -> {}", path.display(), target.display()))?;
                                               ^0      ^0               ^0              ^0                ^0
  359|       |
  360|      3|            let mut symlink_info = None;
  361|      3|            if rule.create_symlink.unwrap_or(false) {
  362|       |                #[cfg(windows)]
  363|      0|                let res = std::os::windows::fs::symlink_file(&target, &path);
  364|       |                #[cfg(unix)]
  365|       |                let res = std::os::unix::fs::symlink(&target, &path);
  366|       |
  367|      0|                match res {
  368|       |                    Ok(_) => {
  369|      0|                        symlink_info = Some("Symlink created".to_string());
  370|       |                        #[cfg(windows)]
  371|      0|                        {
  372|      0|                            let _ = std::process::Command::new("attrib")
  373|      0|                                .arg("+h")
  374|      0|                                .arg(&path)
  375|      0|                                .arg("/L")
  376|      0|                                .creation_flags(0x08000000) // CREATE_NO_WINDOW
  377|      0|                                .status();
  378|      0|                        }
  379|       |                    }
  380|      0|                    Err(e) => symlink_info = Some(format!("Symlink failed: {}", e)),
  381|       |                }
  382|      3|            }
  383|       |
  384|      3|            actions.push((path, target.clone(), rule.name.clone(), symlink_info));
  385|      0|        }
  386|       |    }
  387|      3|    Ok(actions)
  388|      3|}
  389|       |
  390|       |/// Continuously polls the download directory and runs organization logic.
  391|       |///
  392|       |/// This runs `organize_once` in a loop, sleeping for `interval_secs` between iterations.
  393|       |/// When actions are taken, the `callback` is invoked with the list of actions.
  394|       |/// The function checks the `should_continue` flag on each iteration; when set to false, it exits.
  395|      2|pub fn watch_polling<F>(
  396|      2|    cfg: &DownloadsConfig,
  397|      2|    interval_secs: u64,
  398|      2|    should_continue: &std::sync::atomic::AtomicBool,
  399|      2|    callback: F,
  400|      2|) -> Result<()>
  401|      2|where
  402|      2|    F: Fn(&[OrganizeResult]),
  403|       |{
  404|       |    use std::sync::atomic::Ordering;
  405|       |    loop {
  406|      2|        if !should_continue.load(Ordering::Relaxed) {
  407|      2|            break;
  408|      0|        }
  409|      0|        match organize_once(cfg) {
  410|      0|            Ok(actions) => {
  411|      0|                if !actions.is_empty() {
  412|      0|                    callback(&actions);
  413|      0|                }
  414|       |            }
  415|      0|            Err(e) => eprintln!("organize error: {}", e),
  416|       |        }
  417|      0|        thread::sleep(Duration::from_secs(interval_secs));
  418|       |    }
  419|      2|    Ok(())
  420|      2|}
  421|       |
  422|     11|fn expand_env(input: &str) -> String {
  423|     11|    let mut out = String::with_capacity(input.len());
  424|     11|    let mut i = 0;
  425|     11|    let bytes = input.as_bytes();
  426|    229|    while i < bytes.len() {
  427|    218|        if bytes[i] == b'%' {
  428|      3|            if let Some(end) = input[i + 1..].find('%') {
  429|      3|                let var = &input[i + 1..i + 1 + end];
  430|      3|                let val = std::env::var(var).unwrap_or_else(|_| "".to_string());
                                                                              ^1 ^1
  431|      3|                out.push_str(&val);
  432|      3|                i += end + 2;
  433|      3|                continue;
  434|      0|            }
  435|    215|        }
  436|    215|        out.push(bytes[i] as char);
  437|    215|        i += 1;
  438|       |    }
  439|     11|    out
  440|     11|}
  441|       |
  442|       |/// Scans the download directory for old symlinks created by Harbor and removes them.
  443|       |///
  444|       |/// A symlink is considered "old" (and safe to remove) if:
  445|       |/// 1. It is a valid symbolic link.
  446|       |/// 2. It points to a file inside one of the configured `target_dirs`.
  447|       |///
  448|       |/// Returns the number of symlinks removed.
  449|      2|pub fn cleanup_old_symlinks(cfg: &DownloadsConfig) -> Result<usize> {
  450|      2|    let base = PathBuf::from(&cfg.download_dir);
  451|      2|    if !base.exists() {
  452|      0|        return Ok(0);
  453|      2|    }
  454|       |
  455|      2|    let mut count = 0;
  456|       |    // Collect target dirs to check against
  457|      2|    let target_dirs: Vec<PathBuf> = cfg
  458|      2|        .rules
  459|      2|        .iter()
  460|      2|        .map(|r| PathBuf::from(&r.target_dir))
                               ^1            ^1
  461|      2|        .collect();
  462|       |
  463|      5|    for entry in fs::read_dir(&base).with_context(|| format!("list {}", base.display()))? {
                               ^2           ^2     ^2              ^0      ^0         ^0              ^0
  464|      5|        let entry = entry?;
                                       ^0
  465|      5|        let path = entry.path();
  466|       |
  467|      5|        let meta = match fs::symlink_metadata(&path) {
  468|      5|            Ok(m) => m,
  469|      0|            Err(_) => continue,
  470|       |        };
  471|       |
  472|      5|        if meta.file_type().is_symlink() {
  473|       |            // Check if it points to one of our folders
  474|      1|            if let Ok(target) = fs::read_link(&path) {
  475|       |                // If relative symlink, resolve it relative to base
  476|      1|                let abs_target = if target.is_relative() {
  477|      0|                    base.join(&target)
  478|       |                } else {
  479|      1|                    target
  480|       |                };
  481|       |
  482|      1|                let points_to_our_dir = target_dirs.iter().any(|d| abs_target.starts_with(d));
  483|       |
  484|      1|                if points_to_our_dir {
  485|       |                    // It's one of ours, delete it
  486|      1|                    if fs::remove_file(&path).is_ok() {
  487|      1|                        count += 1;
  488|      1|                    }
                                  ^0
  489|      0|                }
  490|      0|            }
  491|      4|        }
  492|       |    }
  493|      2|    Ok(count)
  494|      2|}
  495|       |
  496|       |#[cfg(test)]
  497|       |mod tests {
  498|       |    use super::*;
  499|       |    use std::io::Write;
  500|       |    use tempfile::TempDir;
  501|       |
  502|       |    #[test]
  503|      1|    fn test_expand_env() {
  504|      1|        std::env::set_var("TEST_VAR", "world");
  505|      1|        assert_eq!(expand_env("Hello %TEST_VAR%"), "Hello world");
  506|      1|        assert_eq!(expand_env("%TEST_VAR%"), "world");
  507|      1|        assert_eq!(expand_env("No vars"), "No vars");
  508|      1|        assert_eq!(expand_env("Unknown %MISSING_VAR%"), "Unknown ");
  509|      1|    }
  510|       |
  511|       |    #[test]
  512|      1|    fn test_is_partial() {
  513|      1|        assert!(is_partial("file.crdownload"));
  514|      1|        assert!(is_partial("file.part"));
  515|      1|        assert!(is_partial("file.tmp"));
  516|      1|        assert!(is_partial("file.download"));
  517|      1|        assert!(is_partial("FILE.CRDOWNLOAD")); // Case check
  518|      1|        assert!(!is_partial("file.txt"));
  519|      1|        assert!(!is_partial("image.png"));
  520|      1|    }
  521|       |
  522|       |    #[test]
  523|      1|    fn test_matches_rule() {
  524|      1|        let temp = TempDir::new().unwrap();
  525|      1|        let file_path = temp.path().join("test.png");
  526|      1|        {
  527|      1|            let mut f = fs::File::create(&file_path).unwrap();
  528|      1|            f.write_all(b"123").unwrap(); // 3 bytes
  529|      1|        }
  530|      1|        let meta = fs::metadata(&file_path).unwrap();
  531|       |
  532|      1|        let rule_ext = Rule {
  533|      1|            name: "Ext".into(),
  534|      1|            extensions: Some(vec!["png".into()]),
  535|      1|            pattern: None,
  536|      1|            min_size_bytes: None,
  537|      1|            max_size_bytes: None,
  538|      1|            target_dir: "target".into(),
  539|      1|            create_symlink: None,
  540|      1|            enabled: None,
  541|      1|        };
  542|      1|        assert!(matches_rule(&file_path, &meta, &rule_ext));
  543|       |
  544|      1|        let rule_pat = Rule {
  545|      1|            name: "Pat".into(),
  546|      1|            extensions: None,
  547|      1|            pattern: Some(".*st\\.png".into()),
  548|      1|            min_size_bytes: None,
  549|      1|            max_size_bytes: None,
  550|      1|            target_dir: "target".into(),
  551|      1|            create_symlink: None,
  552|      1|            enabled: None,
  553|      1|        };
  554|      1|        assert!(matches_rule(&file_path, &meta, &rule_pat));
  555|       |
  556|      1|        let rule_size = Rule {
  557|      1|            name: "Size".into(),
  558|      1|            extensions: None,
  559|      1|            pattern: None,
  560|      1|            min_size_bytes: Some(2),
  561|      1|            max_size_bytes: Some(10),
  562|      1|            target_dir: "target".into(),
  563|      1|            create_symlink: None,
  564|      1|            enabled: None,
  565|      1|        };
  566|      1|        assert!(matches_rule(&file_path, &meta, &rule_size));
  567|       |
  568|      1|        let rule_fail = Rule {
  569|      1|            name: "Fail".into(),
  570|      1|            extensions: Some(vec!["jpg".into()]),
  571|      1|            pattern: None,
  572|      1|            min_size_bytes: None,
  573|      1|            max_size_bytes: None,
  574|      1|            target_dir: "target".into(),
  575|      1|            create_symlink: None,
  576|      1|            enabled: None,
  577|      1|        };
  578|      1|        assert!(!matches_rule(&file_path, &meta, &rule_fail));
  579|      1|    }
  580|       |
  581|       |    #[test]
  582|      1|    fn test_unique_target() {
  583|      1|        let temp = TempDir::new().unwrap();
  584|      1|        let target = temp.path().join("file.txt");
  585|       |
  586|       |        // 1. Doesn't exist
  587|      1|        assert_eq!(unique_target(&target), target);
  588|       |
  589|       |        // 2. Exists
  590|      1|        fs::File::create(&target).unwrap();
  591|      1|        let expected = temp.path().join("file (1).txt");
  592|      1|        assert_eq!(unique_target(&target), expected);
  593|       |
  594|       |        // 3. (1) Exists
  595|      1|        fs::File::create(&expected).unwrap();
  596|      1|        let expected_2 = temp.path().join("file (2).txt");
  597|      1|        assert_eq!(unique_target(&target), expected_2);
  598|      1|    }
  599|       |
  600|       |    #[test]
  601|      1|    fn test_organize_basic() {
  602|      1|        let root = TempDir::new().unwrap();
  603|      1|        let dl = root.path().join("Downloads");
  604|      1|        let target = root.path().join("Images");
  605|      1|        fs::create_dir(&dl).unwrap();
  606|       |
  607|       |        // Create file
  608|      1|        let file_path = dl.join("test.png");
  609|      1|        {
  610|      1|            let mut f = fs::File::create(&file_path).unwrap();
  611|      1|            f.write_all(b"data").unwrap();
  612|      1|        }
  613|       |
  614|       |        // Create config
  615|      1|        let cfg = DownloadsConfig {
  616|      1|            download_dir: dl.to_str().unwrap().into(),
  617|      1|            min_age_secs: Some(0), // Immediate move
  618|      1|            tutorial_completed: None,
  619|      1|            service_enabled: None,
  620|      1|            rules: vec![Rule {
  621|      1|                name: "Images".into(),
  622|      1|                extensions: Some(vec!["png".into()]),
  623|      1|                pattern: None,
  624|      1|                min_size_bytes: None,
  625|      1|                max_size_bytes: None,
  626|      1|                target_dir: target.to_str().unwrap().into(),
  627|      1|                create_symlink: Some(false),
  628|      1|                enabled: None,
  629|      1|            }],
  630|      1|        };
  631|       |
  632|       |        // Run
  633|      1|        let actions = organize_once(&cfg).unwrap();
  634|      1|        assert_eq!(actions.len(), 1);
  635|      1|        assert!(!file_path.exists());
  636|      1|        assert!(target.join("test.png").exists());
  637|      1|    }
  638|       |
  639|       |    #[test]
  640|      1|    fn test_cleanup_old_symlinks() {
  641|      1|        let root = TempDir::new().unwrap();
  642|      1|        let dl = root.path().join("Downloads");
  643|      1|        let target = root.path().join("Images");
  644|      1|        fs::create_dir_all(&dl).unwrap();
  645|      1|        fs::create_dir_all(&target).unwrap();
  646|       |
  647|       |        // Create a symlink in dl -> target
  648|      1|        let symlink_path = dl.join("link.png");
  649|       |
  650|       |        #[cfg(windows)]
  651|      1|        let res = std::os::windows::fs::symlink_file(&target, &symlink_path);
  652|       |        #[cfg(unix)]
  653|       |        let res = std::os::unix::fs::symlink(&target, &symlink_path);
  654|       |
  655|       |        // If we can't create symlinks (permissions), skip test
  656|      1|        if res.is_err() {
  657|      0|            return;
  658|      1|        }
  659|       |
  660|      1|        let cfg = DownloadsConfig {
  661|      1|            download_dir: dl.to_str().unwrap().into(),
  662|      1|            rules: vec![Rule {
  663|      1|                name: "Images".into(),
  664|      1|                extensions: None,
  665|      1|                pattern: None,
  666|      1|                min_size_bytes: None,
  667|      1|                max_size_bytes: None,
  668|      1|                target_dir: target.to_str().unwrap().into(),
  669|      1|                create_symlink: None,
  670|      1|                enabled: None,
  671|      1|            }],
  672|      1|            min_age_secs: None,
  673|      1|            tutorial_completed: None,
  674|      1|            service_enabled: None,
  675|      1|        };
  676|       |
  677|       |        // Clean up
  678|      1|        let count = cleanup_old_symlinks(&cfg).unwrap();
  679|      1|        assert_eq!(count, 1);
  680|      1|        assert!(!symlink_path.exists());
  681|      1|    }
  682|       |
  683|       |    #[test]
  684|      1|    fn test_load_downloads_config() {
  685|      1|        let mut file = tempfile::Builder::new().suffix(".yaml").tempfile().unwrap();
  686|      1|        writeln!(
  687|      1|            file,
  688|      1|            r#"
  689|      1|download_dir: "C:\\Downloads"
  690|      1|rules:
  691|      1|  - name: test
  692|      1|    target_dir: "C:\\Target"
  693|      1|"#
  694|       |        )
  695|      1|        .unwrap();
  696|       |
  697|      1|        let cfg = load_downloads_config(file.path()).unwrap();
  698|      1|        assert_eq!(cfg.rules.len(), 1);
  699|      1|        assert_eq!(cfg.rules[0].name, "test");
  700|      1|    }
  701|       |
  702|       |    #[test]
  703|      1|    fn test_default_config() {
  704|      1|        let cfg = default_config();
  705|      1|        assert!(cfg.download_dir.contains("Downloads"));
  706|      1|        assert_eq!(cfg.service_enabled, Some(true));
  707|      1|        assert!(cfg.rules.len() > 0);
  708|      1|        assert!(cfg.rules.iter().any(|r| r.name == "Images"));
  709|      1|    }
  710|       |}

C:\Users\eduard\Documents\github\Harbor\crates\core\src\health.rs:
    1|       |use crate::types::{HealthCheck, HealthCheckKind};
    2|       |use anyhow::{bail, Context, Result};
    3|       |use std::net::{SocketAddr, TcpStream};
    4|       |use std::process::Command;
    5|       |use std::thread;
    6|       |use std::time::{Duration, Instant};
    7|       |
    8|      3|fn attempt(hc: &HealthCheck) -> Result<()> {
    9|      3|    match hc.kind {
   10|      0|        HealthCheckKind::None => Ok(()),
   11|       |        HealthCheckKind::Http => {
   12|      0|            let url = hc.url.clone().unwrap_or_default();
   13|      0|            let res = ureq::get(&url)
   14|      0|                .timeout(Duration::from_millis(hc.timeout_ms.unwrap_or(5000)))
   15|      0|                .call();
   16|      0|            match res {
   17|      0|                Ok(r) => {
   18|      0|                    let s = r.status();
   19|      0|                    if (200..400).contains(&s) {
   20|      0|                        Ok(())
   21|       |                    } else {
   22|      0|                        bail!("http {}", s)
   23|       |                    }
   24|       |                }
   25|      0|                Err(e) => bail!("http err {}", e),
   26|       |            }
   27|       |        }
   28|       |        HealthCheckKind::Tcp => {
   29|      1|            let port = hc.tcp_port.unwrap_or(0);
   30|      1|            let addr = SocketAddr::from(([127, 0, 0, 1], port));
   31|      1|            if TcpStream::connect_timeout(
   32|      1|                &addr,
   33|      1|                Duration::from_millis(hc.timeout_ms.unwrap_or(2000)),
   34|      1|            )
   35|      1|            .is_ok()
   36|       |            {
   37|      1|                Ok(())
   38|       |            } else {
   39|      0|                bail!("tcp")
   40|       |            }
   41|       |        }
   42|       |        HealthCheckKind::Command => {
   43|      2|            let cmd = hc.command.clone().unwrap_or_default();
   44|      2|            if cmd.is_empty() {
   45|      0|                bail!("empty command")
   46|      2|            }
   47|      2|            let status = if cfg!(windows) {
   48|      2|                Command::new("cmd")
   49|      2|                    .arg("/C")
   50|      2|                    .arg(cmd)
   51|      2|                    .status()
   52|      2|                    .context("command")?
                                                     ^0
   53|       |            } else {
   54|      0|                Command::new("sh")
   55|      0|                    .arg("-c")
   56|      0|                    .arg(cmd)
   57|      0|                    .status()
   58|      0|                    .context("command")?
   59|       |            };
   60|      2|            if status.success() {
   61|      1|                Ok(())
   62|       |            } else {
   63|      1|                bail!("command failed")
   64|       |            }
   65|       |        }
   66|       |    }
   67|      3|}
   68|       |
   69|      3|pub fn wait_ready(hc: &HealthCheck) -> Result<()> {
   70|      3|    let retries = hc.retries.unwrap_or(10);
   71|      3|    let timeout_ms = hc.timeout_ms.unwrap_or(5000);
   72|      3|    let start = Instant::now();
   73|      3|    for _ in 0..retries {
   74|      3|        let r = attempt(hc);
   75|      3|        if r.is_ok() {
   76|      2|            return Ok(());
   77|      1|        }
   78|      1|        thread::sleep(Duration::from_millis(300));
   79|      1|        if start.elapsed() > Duration::from_millis(timeout_ms * 2) {
   80|      1|            break;
   81|      0|        }
   82|       |    }
   83|      1|    bail!("not ready")
   84|      3|}
   85|       |
   86|       |#[cfg(test)]
   87|       |mod tests {
   88|       |    use super::*;
   89|       |    use crate::types::{HealthCheck, HealthCheckKind};
   90|       |
   91|       |    #[test]
   92|      1|    fn test_wait_ready_command_success() {
   93|      1|        let cmd = if cfg!(windows) { "echo ok" } else { "true" };
                                                                      ^0
   94|      1|        let hc = HealthCheck {
   95|      1|            kind: HealthCheckKind::Command,
   96|      1|            command: Some(cmd.to_string()),
   97|      1|            url: None,
   98|      1|            tcp_port: None,
   99|      1|            timeout_ms: Some(1000),
  100|      1|            retries: Some(1),
  101|      1|        };
  102|      1|        assert!(wait_ready(&hc).is_ok());
  103|      1|    }
  104|       |
  105|       |    #[test]
  106|      1|    fn test_wait_ready_command_fail() {
  107|      1|        let cmd = if cfg!(windows) { "exit 1" } else { "false" };
                                                                     ^0
  108|      1|        let hc = HealthCheck {
  109|      1|            kind: HealthCheckKind::Command,
  110|      1|            command: Some(cmd.to_string()),
  111|      1|            url: None,
  112|      1|            tcp_port: None,
  113|      1|            timeout_ms: Some(100),
  114|      1|            retries: Some(1),
  115|      1|        };
  116|      1|        assert!(wait_ready(&hc).is_err());
  117|      1|    }
  118|       |
  119|       |    #[test]
  120|      1|    fn test_wait_ready_tcp_success() {
  121|       |        // Find a random free port
  122|      1|        let listener = std::net::TcpListener::bind("127.0.0.1:0").unwrap();
  123|      1|        let port = listener.local_addr().unwrap().port();
  124|       |
  125|       |        // Spawn a thread to accept connections (simulating a server)
  126|      1|        thread::spawn(move || {
  127|      1|            let _ = listener.accept();
  128|      1|        });
  129|       |
  130|      1|        let hc = HealthCheck {
  131|      1|            kind: HealthCheckKind::Tcp,
  132|      1|            command: None,
  133|      1|            url: None,
  134|      1|            tcp_port: Some(port),
  135|      1|            timeout_ms: Some(1000),
  136|      1|            retries: Some(3),
  137|      1|        };
  138|      1|        assert!(wait_ready(&hc).is_ok());
  139|      1|    }
  140|       |}

C:\Users\eduard\Documents\github\Harbor\crates\core\src\orchestrator.rs:
    1|       |use crate::health::wait_ready;
    2|       |use crate::state::{write_state, RunningService, State};
    3|       |use crate::types::{Service, WorkspaceConfig};
    4|       |use anyhow::{bail, Context, Result};
    5|       |use std::collections::{HashMap, VecDeque};
    6|       |use std::fs::{create_dir_all, File};
    7|       |use std::path::Path;
    8|       |use std::process::{Child, Command, Stdio};
    9|       |use sysinfo::{Pid, ProcessesToUpdate, System};
   10|       |
   11|      5|fn topo_order(services: &[Service]) -> Result<Vec<String>> {
   12|      5|    let mut indeg: HashMap<String, usize> = HashMap::new();
   13|      5|    let mut adj: HashMap<String, Vec<String>> = HashMap::new();
   14|     14|    for s in services {
                      ^9
   15|      9|        indeg.entry(s.name.clone()).or_default();
   16|      9|    }
   17|     14|    for s in services {
                      ^9
   18|      9|        for d in s.depends_on.clone().unwrap_or_default() {
                          ^4
   19|      4|            indeg.entry(s.name.clone()).and_modify(|e| *e += 1);
   20|      4|            adj.entry(d).or_default().push(s.name.clone());
   21|       |        }
   22|       |    }
   23|      5|    let mut q: VecDeque<String> = indeg
   24|      5|        .iter()
   25|      9|        .filter(|(_, &v)| v == 0)
                       ^5
   26|      5|        .map(|(k, _)| k.clone())
   27|      5|        .collect();
   28|      5|    let mut res = Vec::new();
   29|      5|    let mut indeg_mut = indeg.clone();
   30|     12|    while let Some(u) = q.pop_front() {
                                 ^7
   31|      7|        res.push(u.clone());
   32|      7|        if let Some(neigh) = adj.get(&u) {
                                  ^2
   33|      4|            for v in neigh {
                              ^2
   34|      2|                if let Some(e) = indeg_mut.get_mut(v) {
   35|      2|                    *e -= 1;
   36|      2|                    if *e == 0 {
   37|      2|                        q.push_back(v.clone());
   38|      2|                    }
                                  ^0
   39|      0|                }
   40|       |            }
   41|      5|        }
   42|       |    }
   43|      5|    if res.len() != indeg.len() {
   44|      1|        bail!("cycle in dependencies")
   45|      4|    }
   46|      4|    Ok(res)
   47|      5|}
   48|       |
   49|      3|fn spawn_service(base_dir: &Path, logs_dir: &Path, s: &Service) -> Result<RunningService> {
   50|      3|    let out_path = logs_dir.join(format!("{}.out.log", s.name));
   51|      3|    let err_path = logs_dir.join(format!("{}.err.log", s.name));
   52|      3|    let out_file = File::options().create(true).append(true).open(&out_path)?;
                                                                                          ^0
   53|      3|    let err_file = File::options().create(true).append(true).open(&err_path)?;
                                                                                          ^0
   54|      3|    let mut cmd = if cfg!(windows) {
   55|      3|        let mut c = Command::new("cmd");
   56|      3|        c.arg("/C").arg(&s.command);
   57|      3|        c
   58|       |    } else {
   59|      0|        let mut c = Command::new("sh");
   60|      0|        c.arg("-c").arg(&s.command);
   61|      0|        c
   62|       |    };
   63|      3|    if let Some(cwd) = &s.cwd {
                              ^0
   64|      0|        let p = base_dir.join(cwd);
   65|      0|        cmd.current_dir(p);
   66|      3|    }
   67|      3|    if let Some(env) = &s.env {
                              ^1
   68|      2|        for (k, v) in env {
                           ^1 ^1
   69|      1|            cmd.env(k, v);
   70|      1|        }
   71|      2|    }
   72|      3|    cmd.stdout(Stdio::from(out_file));
   73|      3|    cmd.stderr(Stdio::from(err_file));
   74|      3|    let child: Child = cmd.spawn().context("spawn")?;
                                                                 ^0
   75|      3|    let pid = child.id() as i32;
   76|      3|    let mut sys = System::new_all();
   77|      3|    sys.refresh_processes(ProcessesToUpdate::Some(&[Pid::from_u32(pid as u32)]), true);
   78|      3|    let start_time = sys
   79|      3|        .process(Pid::from_u32(pid as u32))
   80|      3|        .map(|p| p.start_time());
                               ^2^2
   81|      3|    Ok(RunningService {
   82|      3|        name: s.name.clone(),
   83|      3|        pid,
   84|      3|        start_time,
   85|      3|        stdout_log: out_path,
   86|      3|        stderr_log: err_path,
   87|      3|    })
   88|      3|}
   89|       |
   90|      2|pub fn up(
   91|      2|    cfg: &WorkspaceConfig,
   92|      2|    base_dir: impl AsRef<Path>,
   93|      2|    state_path: impl AsRef<Path>,
   94|      2|) -> Result<State> {
   95|      2|    let base = base_dir.as_ref();
   96|      2|    let logs_dir = base.join("logs");
   97|      2|    create_dir_all(&logs_dir)?;
                                           ^0
   98|      2|    let order = topo_order(&cfg.services)?;
                                                       ^0
   99|      2|    let mut by_name: HashMap<String, &Service> = HashMap::new();
  100|      4|    for s in &cfg.services {
                      ^2
  101|      2|        by_name.insert(s.name.clone(), s);
  102|      2|    }
  103|      2|    let mut running: Vec<RunningService> = Vec::new();
  104|      4|    for name in order {
                      ^2
  105|      2|        let s = by_name.get(&name).unwrap();
  106|      2|        let rs = spawn_service(base, &logs_dir, s)?;
                                                                ^0
  107|      2|        if let Some(hc) = &s.health_check {
                                  ^0
  108|      0|            let _ = wait_ready(hc);
  109|      2|        }
  110|      2|        running.push(rs);
  111|       |    }
  112|      2|    let st = State { services: running };
  113|      2|    write_state(state_path, &st)?;
                                              ^0
  114|      2|    Ok(st)
  115|      2|}
  116|       |
  117|      2|pub fn down(state_path: impl AsRef<Path>) -> Result<()> {
  118|      2|    let p = state_path.as_ref();
  119|      2|    let st = crate::state::read_state(p)?;
                                                      ^0
  120|      2|    if st.is_none() {
  121|      0|        return Ok(());
  122|      2|    }
  123|      2|    let st = st.unwrap();
  124|      2|    let mut sys = System::new();
  125|      2|    sys.refresh_processes(ProcessesToUpdate::All, true);
  126|      4|    for s in st.services {
                      ^2
  127|      2|        if let Some(proc_) = sys.process(Pid::from_u32(s.pid as u32)) {
  128|      2|            if let Some(st_time) = s.start_time {
  129|      2|                if proc_.start_time() != st_time {
  130|      0|                    continue;
  131|      2|                }
  132|      0|            }
  133|      2|            let _ = proc_.kill();
  134|      0|        }
  135|       |    }
  136|      2|    std::fs::remove_file(p).ok();
  137|      2|    Ok(())
  138|      2|}
  139|       |
  140|      2|pub fn status(state_path: impl AsRef<Path>) -> Result<Vec<(String, i32, bool)>> {
  141|      2|    let st = crate::state::read_state(state_path)?;
                                                               ^0
  142|      2|    let mut sys = System::new();
  143|      2|    sys.refresh_processes(ProcessesToUpdate::All, true);
  144|      2|    let mut res = Vec::new();
  145|      2|    if let Some(st) = st {
  146|      4|        for s in st.services {
                          ^2
  147|      2|            let mut alive = false;
  148|      2|            if let Some(proc_) = sys.process(Pid::from_u32(s.pid as u32)) {
  149|      2|                if let Some(st_time) = s.start_time {
  150|      2|                    if proc_.start_time() == st_time {
  151|      2|                        alive = true;
  152|      2|                    }
                                  ^0
  153|      0|                } else {
  154|      0|                    alive = true; // Fallback for old state without start_time
  155|      0|                }
  156|      0|            }
  157|      2|            res.push((s.name, s.pid, alive));
  158|       |        }
  159|      0|    }
  160|      2|    Ok(res)
  161|      2|}
  162|       |
  163|       |#[cfg(test)]
  164|       |mod tests {
  165|       |    use super::*;
  166|       |    use crate::types::Service;
  167|       |
  168|      7|    fn make_service(name: &str, depends_on: Vec<&str>) -> Service {
  169|       |        Service {
  170|      7|            name: name.to_string(),
  171|      7|            command: "echo".to_string(),
  172|      7|            cwd: None,
  173|      7|            env: None,
  174|      7|            depends_on: Some(depends_on.into_iter().map(|s| s.to_string()).collect()),
                                                                          ^4^4
  175|      7|            health_check: None,
  176|       |        }
  177|      7|    }
  178|       |
  179|       |    #[test]
  180|      1|    fn test_topo_order_basic() {
  181|      1|        let s1 = make_service("db", vec![]);
  182|      1|        let s2 = make_service("backend", vec!["db"]);
  183|      1|        let s3 = make_service("frontend", vec!["backend"]);
  184|      1|        let services = vec![s1, s2, s3];
  185|       |
  186|      1|        let order = topo_order(&services).unwrap();
  187|      1|        assert_eq!(
  188|       |            order,
  189|      1|            vec![
  190|      1|                "db".to_string(),
  191|      1|                "backend".to_string(),
  192|      1|                "frontend".to_string()
  193|       |            ]
  194|       |        );
  195|      1|    }
  196|       |
  197|       |    #[test]
  198|      1|    fn test_topo_order_independent() {
  199|      1|        let s1 = make_service("a", vec![]);
  200|      1|        let s2 = make_service("b", vec![]);
  201|      1|        let services = vec![s1, s2];
  202|      1|        let order = topo_order(&services).unwrap();
  203|      1|        assert_eq!(order.len(), 2);
  204|      1|        assert!(order.contains(&"a".to_string()));
  205|      1|        assert!(order.contains(&"b".to_string()));
  206|      1|    }
  207|       |
  208|       |    #[test]
  209|      1|    fn test_topo_order_cycle() {
  210|      1|        let s1 = make_service("a", vec!["b"]);
  211|      1|        let s2 = make_service("b", vec!["a"]);
  212|      1|        let services = vec![s1, s2];
  213|      1|        let res = topo_order(&services);
  214|      1|        assert!(res.is_err());
  215|      1|    }
  216|       |
  217|       |    #[test]
  218|      1|    fn test_spawn_service_echo() {
  219|      1|        let temp = tempfile::TempDir::new().unwrap();
  220|      1|        let logs = temp.path().join("logs");
  221|      1|        std::fs::create_dir(&logs).unwrap();
  222|       |
  223|      1|        let s = Service {
  224|      1|            name: "test".to_string(),
  225|      1|            command: if cfg!(windows) {
  226|      1|                "echo hello".to_string()
  227|       |            } else {
  228|      0|                "echo hello".to_string()
  229|       |            },
  230|      1|            cwd: None,
  231|      1|            env: Some([(String::from("TEST_VAR"), String::from("val"))].into()),
  232|      1|            depends_on: None,
  233|      1|            health_check: None,
  234|       |        };
  235|       |
  236|      1|        let res = spawn_service(temp.path(), &logs, &s).unwrap();
  237|      1|        assert_eq!(res.name, "test");
  238|      1|        assert!(res.pid > 0);
  239|       |
  240|       |        // Wait a bit for output
  241|      1|        std::thread::sleep(std::time::Duration::from_millis(50));
  242|      1|        let out = std::fs::read_to_string(&res.stdout_log).unwrap();
  243|      1|        assert!(out.trim().contains("hello"));
  244|      1|    }
  245|       |
  246|       |    #[test]
  247|      1|    fn test_up_and_down() {
  248|      1|        let temp = tempfile::TempDir::new().unwrap();
  249|      1|        let state_path = temp.path().join("state.json");
  250|       |
  251|      1|        let s1 = Service {
  252|      1|            name: "s1".to_string(),
  253|      1|            command: if cfg!(windows) {
  254|       |                // Ping for a few seconds to simulate a running service
  255|      1|                "ping -n 5 127.0.0.1 > nul".to_string()
  256|       |            } else {
  257|      0|                "sleep 5".to_string()
  258|       |            },
  259|      1|            cwd: None,
  260|      1|            env: None,
  261|      1|            depends_on: None,
  262|      1|            health_check: None,
  263|       |        };
  264|       |
  265|      1|        let cfg = WorkspaceConfig { services: vec![s1] };
  266|       |
  267|      1|        let state = up(&cfg, temp.path(), &state_path).unwrap();
  268|      1|        assert_eq!(state.services.len(), 1);
  269|      1|        let pid = state.services[0].pid;
  270|       |
  271|       |        // Check status
  272|      1|        let st = status(&state_path).unwrap();
  273|      1|        assert_eq!(st.len(), 1);
  274|      1|        assert_eq!(st[0].1, pid);
  275|      1|        assert!(st[0].2); // should be alive
  276|       |
  277|       |        // Down
  278|      1|        down(&state_path).unwrap();
  279|       |
  280|       |        // Wait bit for kill
  281|      1|        std::thread::sleep(std::time::Duration::from_millis(100));
  282|       |
  283|      1|        let mut sys = System::new();
  284|      1|        sys.refresh_processes(ProcessesToUpdate::Some(&[Pid::from_u32(pid as u32)]), true);
  285|      1|        assert!(sys.process(Pid::from_u32(pid as u32)).is_none());
  286|      1|    }
  287|       |}

C:\Users\eduard\Documents\github\Harbor\crates\core\src\state.rs:
    1|       |use anyhow::{Context, Result};
    2|       |use serde::{Deserialize, Serialize};
    3|       |use std::fs;
    4|       |use std::path::{Path, PathBuf};
    5|       |
    6|       |#[derive(Debug, Clone, Serialize, Deserialize)]
    7|       |pub struct RunningService {
    8|       |    pub name: String,
    9|       |    pub pid: i32,
   10|       |    #[serde(default)]
   11|       |    pub start_time: Option<u64>,
   12|       |    pub stdout_log: PathBuf,
   13|       |    pub stderr_log: PathBuf,
   14|       |}
   15|       |
   16|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   17|       |pub struct State {
   18|       |    pub services: Vec<RunningService>,
   19|       |}
   20|       |
   21|      4|pub fn read_state(path: impl AsRef<Path>) -> Result<Option<State>> {
   22|      4|    let p = path.as_ref();
   23|      4|    if !p.exists() {
   24|      0|        return Ok(None);
   25|      4|    }
   26|      4|    let content = fs::read_to_string(p).with_context(|| format!("read {}", p.display()))?;
                                                                      ^0      ^0         ^0^0         ^0
   27|      4|    let s: State = serde_json::from_str(&content).context("parse state")?;
                                                                                      ^0
   28|      4|    Ok(Some(s))
   29|      4|}
   30|       |
   31|      2|pub fn write_state(path: impl AsRef<Path>, state: &State) -> Result<()> {
   32|      2|    let p = path.as_ref();
   33|      2|    let content = serde_json::to_string_pretty(state).context("serialize state")?;
                                                                                              ^0
   34|      2|    fs::write(p, content).with_context(|| format!("write {}", p.display()))?;
                                                        ^0      ^0          ^0^0         ^0
   35|      2|    Ok(())
   36|      2|}

C:\Users\eduard\Documents\github\Harbor\crates\core\src\types.rs:
    1|       |use serde::{Deserialize, Serialize};
    2|       |use std::collections::HashMap;
    3|       |
    4|       |#[derive(Debug, Clone, Serialize, Deserialize)]
    5|       |pub struct WorkspaceConfig {
    6|       |    pub services: Vec<Service>,
    7|       |}
    8|       |
    9|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   10|       |pub struct Service {
   11|       |    pub name: String,
   12|       |    pub command: String,
   13|       |    pub cwd: Option<String>,
   14|       |    pub env: Option<HashMap<String, String>>,
   15|       |    pub depends_on: Option<Vec<String>>,
   16|       |    pub health_check: Option<HealthCheck>,
   17|       |}
   18|       |
   19|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   20|       |pub struct HealthCheck {
   21|       |    pub kind: HealthCheckKind,
   22|       |    pub command: Option<String>,
   23|       |    pub url: Option<String>,
   24|       |    pub tcp_port: Option<u16>,
   25|       |    pub timeout_ms: Option<u64>,
   26|       |    pub retries: Option<u32>,
   27|       |}
   28|       |
   29|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   30|       |#[serde(rename_all = "snake_case")]
   31|       |pub enum HealthCheckKind {
   32|       |    Command,
   33|       |    Http,
   34|       |    Tcp,
   35|       |    None,
   36|       |}
   37|       |
   38|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   39|       |pub struct Rule {
   40|       |    pub name: String,
   41|       |    pub extensions: Option<Vec<String>>,
   42|       |    pub pattern: Option<String>,
   43|       |    pub min_size_bytes: Option<u64>,
   44|       |    pub max_size_bytes: Option<u64>,
   45|       |    pub target_dir: String,
   46|       |    pub create_symlink: Option<bool>,
   47|       |    #[serde(default = "default_enabled")]
   48|       |    pub enabled: Option<bool>,
   49|       |}
   50|       |
   51|      2|fn default_enabled() -> Option<bool> {
   52|      2|    Some(true)
   53|      2|}
   54|       |
   55|       |#[cfg(test)]
   56|       |mod tests {
   57|       |    use super::*;
   58|       |
   59|       |    #[test]
   60|      1|    fn test_service_serde() {
   61|      1|        let s = Service {
   62|      1|            name: "test".to_string(),
   63|      1|            command: "echo".to_string(),
   64|      1|            cwd: Some(".".to_string()),
   65|      1|            env: None,
   66|      1|            depends_on: None,
   67|      1|            health_check: None,
   68|      1|        };
   69|      1|        let json = serde_json::to_string(&s).unwrap();
   70|      1|        let s2: Service = serde_json::from_str(&json).unwrap();
   71|      1|        assert_eq!(s.name, s2.name);
   72|      1|    }
   73|       |
   74|       |    #[test]
   75|      1|    fn test_rule_serde() {
   76|      1|        let r = Rule {
   77|      1|            name: "rule".to_string(),
   78|      1|            extensions: Some(vec!["txt".to_string()]),
   79|      1|            pattern: None,
   80|      1|            min_size_bytes: None,
   81|      1|            max_size_bytes: None,
   82|      1|            target_dir: "target".to_string(),
   83|      1|            create_symlink: None,
   84|      1|            enabled: Some(true),
   85|      1|        };
   86|      1|        let json = serde_json::to_string(&r).unwrap();
   87|      1|        let r2: Rule = serde_json::from_str(&json).unwrap();
   88|      1|        assert_eq!(r.name, r2.name);
   89|      1|    }
   90|       |}

C:\Users\eduard\Documents\github\Harbor\crates\tauri-app\src\commands\activity.rs:
    1|       |use crate::state::AppState;
    2|       |use regex::Regex;
    3|       |use serde::{Deserialize, Serialize};
    4|       |use std::fs;
    5|       |use std::io::{BufRead, BufReader};
    6|       |use tauri::State;
    7|       |
    8|       |/// Activity log entry for the frontend
    9|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   10|       |pub struct ActivityLogDto {
   11|       |    pub id: String,
   12|       |    pub timestamp: String,
   13|       |    pub filename: String,
   14|       |    pub icon: String,
   15|       |    pub icon_color: String,
   16|       |    pub source_path: String,
   17|       |    pub dest_path: String,
   18|       |    pub rule_name: String,
   19|       |    pub status: String,
   20|       |    pub symlink_info: Option<String>,
   21|       |}
   22|       |
   23|       |/// Activity statistics
   24|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   25|       |pub struct ActivityStats {
   26|       |    pub total_files_moved: usize,
   27|       |    pub files_moved_today: usize,
   28|       |    pub files_moved_this_week: usize,
   29|       |    pub most_active_rule: Option<String>,
   30|       |}
   31|       |
   32|       |/// Paginated response for activity logs
   33|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   34|       |pub struct ActivityLogsResponse {
   35|       |    pub logs: Vec<ActivityLogDto>,
   36|       |    pub total: usize,
   37|       |    pub has_more: bool,
   38|       |}
   39|       |
   40|      0|fn parse_log_line(line: &str, id: usize) -> Option<ActivityLogDto> {
   41|       |    // Log format: "source_path -> dest_path (rule_name) symlink_info"
   42|       |    // Example: "C:\Downloads\file.jpg -> C:\Images\file.jpg (Images) Symlink created"
   43|       |
   44|      0|    let arrow_pattern = Regex::new(r"^(.+?) -> (.+) \(([^)]+)\)\s*(.*)$").ok()?;
   45|       |
   46|      0|    let caps = arrow_pattern.captures(line)?;
   47|       |
   48|      0|    let source_path = caps.get(1)?.as_str().to_string();
   49|      0|    let dest_path = caps.get(2)?.as_str().to_string();
   50|      0|    let rule_name = caps.get(3)?.as_str().to_string();
   51|      0|    let symlink_info = caps.get(4).map(|m| m.as_str().trim().to_string());
   52|      0|    let symlink_info = if symlink_info.as_ref().map(|s| s.is_empty()).unwrap_or(true) {
   53|      0|        None
   54|       |    } else {
   55|      0|        symlink_info
   56|       |    };
   57|       |
   58|       |    // Extract filename from dest_path
   59|      0|    let filename = std::path::Path::new(&dest_path)
   60|      0|        .file_name()
   61|      0|        .and_then(|n| n.to_str())
   62|      0|        .unwrap_or("unknown")
   63|      0|        .to_string();
   64|       |
   65|       |    // Derive icon from extension
   66|      0|    let ext = std::path::Path::new(&filename)
   67|      0|        .extension()
   68|      0|        .and_then(|e| e.to_str())
   69|      0|        .unwrap_or("")
   70|      0|        .to_lowercase();
   71|       |
   72|      0|    let (icon, icon_color) = derive_icon_and_color(&ext);
   73|       |
   74|      0|    Some(ActivityLogDto {
   75|      0|        id: id.to_string(),
   76|      0|        timestamp: "".to_string(), // We don't have timestamps in current log format
   77|      0|        filename,
   78|      0|        icon,
   79|      0|        icon_color,
   80|      0|        source_path,
   81|      0|        dest_path,
   82|      0|        rule_name,
   83|      0|        status: "success".to_string(),
   84|      0|        symlink_info,
   85|      0|    })
   86|      0|}
   87|       |
   88|      0|fn derive_icon_and_color(ext: &str) -> (String, String) {
   89|      0|    match ext {
   90|      0|        "jpg" | "jpeg" | "png" | "gif" | "webp" | "svg" | "bmp" | "tiff" | "heic" | "avif" => {
   91|      0|            ("image".to_string(), "blue".to_string())
   92|       |        }
   93|      0|        "mp4" | "mkv" | "avi" | "mov" | "wmv" | "webm" => {
   94|      0|            ("movie".to_string(), "indigo".to_string())
   95|       |        }
   96|      0|        "mp3" | "flac" | "wav" | "aac" | "ogg" => ("music_note".to_string(), "pink".to_string()),
   97|      0|        "pdf" => ("description".to_string(), "red".to_string()),
   98|      0|        "doc" | "docx" | "txt" | "rtf" => ("description".to_string(), "blue".to_string()),
   99|      0|        "xls" | "xlsx" | "csv" => ("table_chart".to_string(), "green".to_string()),
  100|      0|        "ppt" | "pptx" => ("slideshow".to_string(), "amber".to_string()),
  101|      0|        "zip" | "rar" | "7z" | "tar" | "gz" | "xz" => {
  102|      0|            ("folder_zip".to_string(), "amber".to_string())
  103|       |        }
  104|      0|        "exe" | "msi" | "msix" | "dmg" | "pkg" | "apk" => {
  105|      0|            ("install_desktop".to_string(), "purple".to_string())
  106|       |        }
  107|      0|        "iso" => ("album".to_string(), "slate".to_string()),
  108|      0|        "torrent" => ("download".to_string(), "green".to_string()),
  109|      0|        "html" | "htm" => ("web".to_string(), "orange".to_string()),
  110|      0|        "json" | "xml" | "yaml" | "yml" => ("code".to_string(), "purple".to_string()),
  111|      0|        "srt" | "vtt" => ("subtitles".to_string(), "slate".to_string()),
  112|      0|        _ => ("insert_drive_file".to_string(), "slate".to_string()),
  113|       |    }
  114|      0|}
  115|       |
  116|      0|#[tauri::command]
  117|      0|pub async fn get_activity_logs(
  118|      0|    state: State<'_, AppState>,
  119|      0|    limit: Option<usize>,
  120|      0|    offset: Option<usize>,
  121|      0|) -> Result<ActivityLogsResponse, String> {
  122|      0|    let log_path = state.recent_log_path();
  123|      0|    let limit = limit.unwrap_or(50);
  124|      0|    let offset = offset.unwrap_or(0);
  125|       |
  126|      0|    if !log_path.exists() {
  127|      0|        return Ok(ActivityLogsResponse {
  128|      0|            logs: vec![],
  129|      0|            total: 0,
  130|      0|            has_more: false,
  131|      0|        });
  132|      0|    }
  133|       |
  134|      0|    let file = fs::File::open(&log_path).map_err(|e| format!("Failed to open log file: {}", e))?;
  135|      0|    let reader = BufReader::new(file);
  136|       |
  137|       |    // Read all lines and parse them
  138|      0|    let mut all_logs: Vec<ActivityLogDto> = reader
  139|      0|        .lines()
  140|      0|        .map_while(Result::ok)
  141|      0|        .filter(|line| {
  142|      0|            !line.trim().is_empty()
  143|      0|                && !line.starts_with("Recent Moves")
  144|      0|                && !line.starts_with("---")
  145|      0|                && !line.starts_with("Startup:")
  146|      0|        })
  147|      0|        .enumerate()
  148|      0|        .filter_map(|(idx, line)| parse_log_line(&line, idx))
  149|      0|        .collect();
  150|       |
  151|       |    // Reverse to show most recent first
  152|      0|    all_logs.reverse();
  153|       |
  154|      0|    let total = all_logs.len();
  155|      0|    let has_more = offset + limit < total;
  156|       |
  157|       |    // Apply pagination
  158|      0|    let logs: Vec<ActivityLogDto> = all_logs.into_iter().skip(offset).take(limit).collect();
  159|       |
  160|      0|    Ok(ActivityLogsResponse {
  161|      0|        logs,
  162|      0|        total,
  163|      0|        has_more,
  164|      0|    })
  165|      0|}
  166|       |
  167|      0|#[tauri::command]
  168|      0|pub async fn get_activity_stats(state: State<'_, AppState>) -> Result<ActivityStats, String> {
  169|      0|    let log_path = state.recent_log_path();
  170|       |
  171|      0|    if !log_path.exists() {
  172|      0|        return Ok(ActivityStats {
  173|      0|            total_files_moved: 0,
  174|      0|            files_moved_today: 0,
  175|      0|            files_moved_this_week: 0,
  176|      0|            most_active_rule: None,
  177|      0|        });
  178|      0|    }
  179|       |
  180|      0|    let file = fs::File::open(&log_path).map_err(|e| format!("Failed to open log file: {}", e))?;
  181|      0|    let reader = BufReader::new(file);
  182|       |
  183|      0|    let mut rule_counts: std::collections::HashMap<String, usize> =
  184|      0|        std::collections::HashMap::new();
  185|      0|    let mut total = 0;
  186|       |
  187|      0|    for line in reader.lines().map_while(Result::ok) {
  188|      0|        if line.trim().is_empty()
  189|      0|            || line.starts_with("Recent Moves")
  190|      0|            || line.starts_with("---")
  191|      0|            || line.starts_with("Startup:")
  192|       |        {
  193|      0|            continue;
  194|      0|        }
  195|       |
  196|      0|        if let Some(log) = parse_log_line(&line, 0) {
  197|      0|            total += 1;
  198|      0|            *rule_counts.entry(log.rule_name).or_insert(0) += 1;
  199|      0|        }
  200|       |    }
  201|       |
  202|      0|    let most_active_rule = rule_counts
  203|      0|        .into_iter()
  204|      0|        .max_by_key(|(_, count)| *count)
  205|      0|        .map(|(name, _)| name);
  206|       |
  207|      0|    Ok(ActivityStats {
  208|      0|        total_files_moved: total,
  209|      0|        files_moved_today: total, // Simplified - we don't have timestamps in current format
  210|      0|        files_moved_this_week: total,
  211|      0|        most_active_rule,
  212|      0|    })
  213|      0|}
  214|       |
  215|      0|#[tauri::command]
  216|      0|pub async fn clear_activity_logs(state: State<'_, AppState>) -> Result<(), String> {
  217|      0|    let log_path = state.recent_log_path();
  218|       |
  219|      0|    if log_path.exists() {
  220|      0|        fs::write(&log_path, "Recent Moves Log\n----------------\n")
  221|      0|            .map_err(|e| format!("Failed to clear log file: {}", e))?;
  222|      0|    }
  223|       |
  224|      0|    Ok(())
  225|      0|}

C:\Users\eduard\Documents\github\Harbor\crates\tauri-app\src\commands\rules.rs:
    1|       |use crate::commands::settings::{internal_start_service, internal_stop_service};
    2|       |use crate::state::AppState;
    3|       |use harbor_core::downloads::DownloadsConfig;
    4|       |use harbor_core::types::Rule;
    5|       |
    6|       |use serde::{Deserialize, Serialize};
    7|       |use std::fs;
    8|       |use tauri::State;
    9|       |
   10|       |/// Frontend-facing rule representation
   11|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   12|       |pub struct RuleDto {
   13|       |    /// Rule name (used as ID)
   14|       |    pub id: String,
   15|       |    /// Display name
   16|       |    pub name: String,
   17|       |    /// File extensions this rule applies to
   18|       |    pub extensions: Vec<String>,
   19|       |    /// Optional regex pattern for filename matching
   20|       |    pub pattern: Option<String>,
   21|       |    /// Minimum file size in bytes
   22|       |    pub min_size_bytes: Option<u64>,
   23|       |    /// Maximum file size in bytes
   24|       |    pub max_size_bytes: Option<u64>,
   25|       |    /// Target directory for matched files
   26|       |    pub destination: String,
   27|       |    /// Whether to create a symlink in the original location
   28|       |    pub create_symlink: bool,
   29|       |    /// Whether the rule is enabled
   30|       |    pub enabled: bool,
   31|       |    /// Icon name (derived from first extension)
   32|       |    pub icon: String,
   33|       |    /// Icon color
   34|       |    pub icon_color: String,
   35|       |}
   36|       |
   37|       |impl From<&Rule> for RuleDto {
   38|      0|    fn from(rule: &Rule) -> Self {
   39|      0|        let icon = derive_icon(rule.extensions.as_ref());
   40|      0|        let icon_color = derive_icon_color(rule.extensions.as_ref());
   41|       |
   42|       |        RuleDto {
   43|      0|            id: rule.name.clone(),
   44|      0|            name: rule.name.clone(),
   45|      0|            extensions: rule
   46|      0|                .extensions
   47|      0|                .clone()
   48|      0|                .unwrap_or_default()
   49|      0|                .into_iter()
   50|      0|                .map(|e| format!(".{}", e))
   51|      0|                .collect(),
   52|      0|            pattern: rule.pattern.clone(),
   53|      0|            min_size_bytes: rule.min_size_bytes,
   54|      0|            max_size_bytes: rule.max_size_bytes,
   55|      0|            destination: rule.target_dir.clone(),
   56|      0|            create_symlink: rule.create_symlink.unwrap_or(false),
   57|      0|            enabled: rule.enabled.unwrap_or(true),
   58|      0|            icon,
   59|      0|            icon_color,
   60|       |        }
   61|      0|    }
   62|       |}
   63|       |
   64|      9|fn derive_icon(extensions: Option<&Vec<String>>) -> String {
   65|      9|    let ext = extensions
   66|      9|        .and_then(|e| e.first())
                                    ^8^8
   67|      9|        .map(|s| s.to_lowercase())
                               ^8^8
   68|      9|        .unwrap_or_default();
   69|       |
   70|      9|    match ext.as_str() {
   71|      9|        "jpg" | "jpeg" | "png" | "gif" | "webp" | "svg" | "bmp" | "tiff" | "heic" | "avif" => {
                              ^8       ^8      ^8      ^8       ^8      ^8      ^8       ^8       ^8
   72|      1|            "image".to_string()
   73|       |        }
   74|      8|        "mp4" | "mkv" | "avi" | "mov" | "wmv" | "webm" => "movie".to_string(),
                              ^7      ^7      ^7      ^7      ^7        ^1      ^1
   75|      7|        "mp3" | "flac" | "wav" | "aac" | "ogg" => "music_note".to_string(),
                              ^6       ^6      ^6      ^6       ^1           ^1
   76|      6|        "pdf" | "doc" | "docx" | "txt" | "rtf" => "description".to_string(),
                              ^5      ^5       ^5      ^5       ^1            ^1
   77|      5|        "xls" | "xlsx" | "csv" => "table_chart".to_string(),
                                       ^4       ^1            ^1
   78|      4|        "ppt" | "pptx" => "slideshow".to_string(),
                                        ^0          ^0
   79|      4|        "zip" | "rar" | "7z" | "tar" | "gz" | "xz" => "folder_zip".to_string(),
                              ^3      ^3     ^3      ^3     ^3      ^1           ^1
   80|      3|        "exe" | "msi" | "msix" | "dmg" | "pkg" | "apk" => "install_desktop".to_string(),
                              ^2      ^2       ^2      ^2      ^2       ^1                ^1
   81|      2|        "iso" => "album".to_string(),
                               ^0      ^0
   82|      2|        "torrent" => "download".to_string(),
                                   ^0         ^0
   83|      2|        "html" | "htm" => "web".to_string(),
                                        ^0    ^0
   84|      2|        "json" | "xml" | "yaml" | "yml" => "code".to_string(),
                                                         ^0     ^0
   85|      2|        "srt" | "vtt" => "subtitles".to_string(),
                                       ^0          ^0
   86|      2|        _ => "insert_drive_file".to_string(),
   87|       |    }
   88|      9|}
   89|       |
   90|      8|fn derive_icon_color(extensions: Option<&Vec<String>>) -> String {
   91|      8|    let ext = extensions
   92|      8|        .and_then(|e| e.first())
                                    ^7^7
   93|      8|        .map(|s| s.to_lowercase())
                               ^7^7
   94|      8|        .unwrap_or_default();
   95|       |
   96|      8|    match ext.as_str() {
   97|      8|        "jpg" | "jpeg" | "png" | "gif" | "webp" | "svg" | "bmp" | "tiff" | "heic" | "avif" => {
                              ^7       ^7      ^7      ^7       ^7      ^7      ^7       ^7       ^7
   98|      1|            "indigo".to_string()
   99|       |        }
  100|      7|        "mp4" | "mkv" | "avi" | "mov" | "wmv" | "webm" => "purple".to_string(),
                              ^6      ^6      ^6      ^6      ^6        ^1       ^1
  101|      6|        "mp3" | "flac" | "wav" | "aac" | "ogg" => "pink".to_string(),
                              ^5       ^5      ^5      ^5       ^1     ^1
  102|      5|        "pdf" | "doc" | "docx" | "txt" | "rtf" | "xls" | "xlsx" | "csv" | "ppt" | "pptx" => {
                              ^4      ^4       ^4      ^4      ^4      ^4       ^4      ^4      ^4
  103|      1|            "amber".to_string()
  104|       |        }
  105|      4|        "zip" | "rar" | "7z" | "tar" | "gz" | "xz" => "slate".to_string(),
                              ^3      ^3     ^3      ^3     ^3      ^1      ^1
  106|      3|        "exe" | "msi" | "msix" | "dmg" | "pkg" | "apk" => "red".to_string(),
                              ^2      ^2       ^2      ^2      ^2       ^1    ^1
  107|      2|        _ => "slate".to_string(),
  108|       |    }
  109|      8|}
  110|       |
  111|      0|fn save_config(state: &AppState, config: &DownloadsConfig) -> Result<(), String> {
  112|      0|    let yaml =
  113|      0|        serde_yaml::to_string(config).map_err(|e| format!("Failed to serialize config: {}", e))?;
  114|      0|    fs::write(&state.config_path, yaml).map_err(|e| format!("Failed to write config: {}", e))?;
  115|      0|    Ok(())
  116|      0|}
  117|       |
  118|      0|fn restart_service_if_running(state: &AppState) -> Result<(), String> {
  119|      0|    let flag_guard = state.watcher_flag.lock().map_err(|e| e.to_string())?;
  120|      0|    let is_running = flag_guard.is_some();
  121|      0|    drop(flag_guard);
  122|       |
  123|      0|    if is_running {
  124|      0|        internal_stop_service(state)?;
  125|      0|        internal_start_service(state)?;
  126|      0|    }
  127|      0|    Ok(())
  128|      0|}
  129|       |
  130|      0|#[tauri::command]
  131|      0|pub async fn get_rules(state: State<'_, AppState>) -> Result<Vec<RuleDto>, String> {
  132|      0|    let config = state.config.read().map_err(|e| e.to_string())?;
  133|      0|    Ok(config.rules.iter().map(RuleDto::from).collect())
  134|      0|}
  135|       |
  136|      0|#[tauri::command]
  137|       |#[allow(clippy::too_many_arguments)]
  138|      0|pub async fn create_rule(
  139|      0|    state: State<'_, AppState>,
  140|      0|    name: String,
  141|      0|    extensions: Vec<String>,
  142|      0|    destination: String,
  143|      0|    pattern: Option<String>,
  144|      0|    min_size_bytes: Option<u64>,
  145|      0|    max_size_bytes: Option<u64>,
  146|      0|    create_symlink: Option<bool>,
  147|      0|    enabled: Option<bool>,
  148|      0|) -> Result<RuleDto, String> {
  149|      0|    let new_rule = {
  150|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  151|       |
  152|       |        // Check if rule with this name already exists
  153|      0|        if config.rules.iter().any(|r| r.name == name) {
  154|      0|            return Err(format!("Rule with name '{}' already exists", name));
  155|      0|        }
  156|       |
  157|       |        // Convert extensions: remove leading dots if present
  158|      0|        let extensions: Vec<String> = extensions
  159|      0|            .into_iter()
  160|      0|            .map(|e| e.trim_start_matches('.').to_string())
  161|      0|            .filter(|e| !e.is_empty())
  162|      0|            .collect();
  163|       |
  164|      0|        let rule = Rule {
  165|      0|            name: name.clone(),
  166|      0|            extensions: if extensions.is_empty() {
  167|      0|                None
  168|       |            } else {
  169|      0|                Some(extensions)
  170|       |            },
  171|      0|            pattern,
  172|      0|            min_size_bytes,
  173|      0|            max_size_bytes,
  174|      0|            target_dir: destination,
  175|      0|            create_symlink,
  176|      0|            enabled,
  177|       |        };
  178|       |
  179|      0|        config.rules.push(rule.clone());
  180|      0|        save_config(&state, &config)?;
  181|      0|        rule
  182|       |    };
  183|       |
  184|      0|    restart_service_if_running(&state)?;
  185|       |
  186|      0|    Ok(RuleDto::from(&new_rule))
  187|      0|}
  188|       |
  189|      0|#[tauri::command]
  190|       |#[allow(clippy::too_many_arguments)]
  191|      0|pub async fn update_rule(
  192|      0|    state: State<'_, AppState>,
  193|      0|    id: String,
  194|      0|    name: Option<String>,
  195|      0|    extensions: Option<Vec<String>>,
  196|      0|    destination: Option<String>,
  197|      0|    pattern: Option<String>,
  198|      0|    min_size_bytes: Option<u64>,
  199|      0|    max_size_bytes: Option<u64>,
  200|      0|    create_symlink: Option<bool>,
  201|      0|    enabled: Option<bool>,
  202|      0|) -> Result<RuleDto, String> {
  203|      0|    let updated = {
  204|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  205|       |
  206|      0|        let rule = config
  207|      0|            .rules
  208|      0|            .iter_mut()
  209|      0|            .find(|r| r.name == id)
  210|      0|            .ok_or_else(|| format!("Rule '{}' not found", id))?;
  211|       |
  212|      0|        if let Some(new_name) = name {
  213|      0|            rule.name = new_name;
  214|      0|        }
  215|      0|        if let Some(exts) = extensions {
  216|      0|            let exts: Vec<String> = exts
  217|      0|                .into_iter()
  218|      0|                .map(|e| e.trim_start_matches('.').to_string())
  219|      0|                .filter(|e| !e.is_empty())
  220|      0|                .collect();
  221|      0|            rule.extensions = if exts.is_empty() { None } else { Some(exts) };
  222|      0|        }
  223|      0|        if let Some(dest) = destination {
  224|      0|            rule.target_dir = dest;
  225|      0|        }
  226|      0|        if pattern.is_some() {
  227|      0|            rule.pattern = pattern;
  228|      0|        }
  229|      0|        if min_size_bytes.is_some() {
  230|      0|            rule.min_size_bytes = min_size_bytes;
  231|      0|        }
  232|      0|        if max_size_bytes.is_some() {
  233|      0|            rule.max_size_bytes = max_size_bytes;
  234|      0|        }
  235|      0|        if let Some(symlink) = create_symlink {
  236|      0|            rule.create_symlink = Some(symlink);
  237|      0|        }
  238|      0|        if let Some(en) = enabled {
  239|      0|            rule.enabled = Some(en);
  240|      0|        }
  241|       |
  242|      0|        let updated = RuleDto::from(&*rule);
  243|      0|        save_config(&state, &config)?;
  244|      0|        updated
  245|       |    };
  246|       |
  247|      0|    restart_service_if_running(&state)?;
  248|       |
  249|      0|    Ok(updated)
  250|      0|}
  251|       |
  252|      0|#[tauri::command]
  253|      0|pub async fn delete_rule(state: State<'_, AppState>, rule_name: String) -> Result<(), String> {
  254|       |    {
  255|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  256|       |
  257|      0|        let original_len = config.rules.len();
  258|      0|        config.rules.retain(|r| r.name != rule_name);
  259|       |
  260|      0|        if config.rules.len() == original_len {
  261|      0|            return Err(format!("Rule '{}' not found", rule_name));
  262|      0|        }
  263|       |
  264|      0|        save_config(&state, &config)?;
  265|       |    }
  266|      0|    restart_service_if_running(&state)?;
  267|      0|    Ok(())
  268|      0|}
  269|       |
  270|      0|#[tauri::command]
  271|      0|pub async fn toggle_rule(
  272|      0|    state: State<'_, AppState>,
  273|      0|    rule_name: String,
  274|      0|    enabled: bool,
  275|      0|) -> Result<(), String> {
  276|       |    {
  277|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  278|       |
  279|      0|        let rule = config
  280|      0|            .rules
  281|      0|            .iter_mut()
  282|      0|            .find(|r| r.name == rule_name)
  283|      0|            .ok_or_else(|| format!("Rule '{}' not found", rule_name))?;
  284|       |
  285|      0|        rule.enabled = Some(enabled);
  286|      0|        save_config(&state, &config)?;
  287|       |    }
  288|      0|    restart_service_if_running(&state)?;
  289|       |
  290|      0|    Ok(())
  291|      0|}
  292|       |
  293|      0|#[tauri::command]
  294|      0|pub async fn reorder_rules(
  295|      0|    state: State<'_, AppState>,
  296|      0|    rule_names: Vec<String>,
  297|      0|) -> Result<(), String> {
  298|       |    {
  299|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  300|       |
  301|       |        // Reorder rules based on the provided order
  302|      0|        let mut new_rules: Vec<Rule> = Vec::with_capacity(rule_names.len());
  303|       |
  304|      0|        for name in &rule_names {
  305|      0|            if let Some(rule) = config.rules.iter().find(|r| &r.name == name).cloned() {
  306|      0|                new_rules.push(rule);
  307|      0|            }
  308|       |        }
  309|       |
  310|       |        // Add any rules that weren't in the provided list (shouldn't happen, but safety first)
  311|      0|        for rule in &config.rules {
  312|      0|            if !rule_names.contains(&rule.name) {
  313|      0|                new_rules.push(rule.clone());
  314|      0|            }
  315|       |        }
  316|       |
  317|      0|        config.rules = new_rules;
  318|      0|        save_config(&state, &config)?;
  319|       |    }
  320|      0|    restart_service_if_running(&state)?;
  321|       |
  322|      0|    Ok(())
  323|      0|}
  324|       |
  325|      0|#[tauri::command]
  326|      0|pub async fn get_download_dir(state: State<'_, AppState>) -> Result<String, String> {
  327|      0|    let config = state.config.read().map_err(|e| e.to_string())?;
  328|      0|    Ok(config.download_dir.clone())
  329|      0|}
  330|       |
  331|       |#[cfg(test)]
  332|       |mod tests {
  333|       |    use super::*;
  334|       |
  335|       |    #[test]
  336|      1|    fn test_derive_icon() {
  337|      1|        assert_eq!(derive_icon(Some(&vec!["jpg".to_string()])), "image");
  338|      1|        assert_eq!(derive_icon(Some(&vec!["mp4".to_string()])), "movie");
  339|      1|        assert_eq!(derive_icon(Some(&vec!["mp3".to_string()])), "music_note");
  340|      1|        assert_eq!(derive_icon(Some(&vec!["pdf".to_string()])), "description");
  341|      1|        assert_eq!(derive_icon(Some(&vec!["xlsx".to_string()])), "table_chart");
  342|      1|        assert_eq!(derive_icon(Some(&vec!["zip".to_string()])), "folder_zip");
  343|      1|        assert_eq!(
  344|      1|            derive_icon(Some(&vec!["exe".to_string()])),
  345|       |            "install_desktop"
  346|       |        );
  347|      1|        assert_eq!(
  348|      1|            derive_icon(Some(&vec!["unknown".to_string()])),
  349|       |            "insert_drive_file"
  350|       |        );
  351|      1|        assert_eq!(derive_icon(None), "insert_drive_file");
  352|      1|    }
  353|       |
  354|       |    #[test]
  355|      1|    fn test_derive_icon_color() {
  356|      1|        assert_eq!(derive_icon_color(Some(&vec!["jpg".to_string()])), "indigo");
  357|      1|        assert_eq!(derive_icon_color(Some(&vec!["mp4".to_string()])), "purple");
  358|      1|        assert_eq!(derive_icon_color(Some(&vec!["mp3".to_string()])), "pink");
  359|      1|        assert_eq!(derive_icon_color(Some(&vec!["pdf".to_string()])), "amber");
  360|      1|        assert_eq!(derive_icon_color(Some(&vec!["zip".to_string()])), "slate");
  361|      1|        assert_eq!(derive_icon_color(Some(&vec!["exe".to_string()])), "red");
  362|      1|        assert_eq!(
  363|      1|            derive_icon_color(Some(&vec!["unknown".to_string()])),
  364|       |            "slate"
  365|       |        );
  366|      1|        assert_eq!(derive_icon_color(None), "slate");
  367|      1|    }
  368|       |}

C:\Users\eduard\Documents\github\Harbor\crates\tauri-app\src\commands\settings.rs:
    1|       |use crate::state::AppState;
    2|       |use harbor_core::downloads::{load_downloads_config, organize_once, watch_polling};
    3|       |use serde::{Deserialize, Serialize};
    4|       |use std::fs;
    5|       |use std::io::Write;
    6|       |use std::path::PathBuf;
    7|       |use std::sync::atomic::Ordering;
    8|       |use std::sync::Arc;
    9|       |use std::thread;
   10|       |use tauri::State;
   11|       |
   12|       |#[cfg(windows)]
   13|       |use winreg::enums::*;
   14|       |#[cfg(windows)]
   15|       |use winreg::RegKey;
   16|       |
   17|       |/// Service status information
   18|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   19|       |pub struct ServiceStatus {
   20|       |    pub running: bool,
   21|       |    pub uptime_seconds: Option<u64>,
   22|       |}
   23|       |
   24|      0|fn append_to_log(log_path: &PathBuf, actions: &[(PathBuf, PathBuf, String, Option<String>)]) {
   25|      0|    if actions.is_empty() {
   26|      0|        return;
   27|      0|    }
   28|       |
   29|      0|    if let Some(parent) = log_path.parent() {
   30|      0|        let _ = fs::create_dir_all(parent);
   31|      0|    }
   32|       |
   33|      0|    let mut buf = String::new();
   34|      0|    for (from, to, rule, symlink_info) in actions {
   35|      0|        let symlink_msg = symlink_info.as_deref().unwrap_or("");
   36|      0|        buf.push_str(&format!(
   37|      0|            "{} -> {} ({}) {}\n",
   38|      0|            from.display(),
   39|      0|            to.display(),
   40|      0|            rule,
   41|      0|            symlink_msg
   42|      0|        ));
   43|      0|    }
   44|       |
   45|      0|    if let Ok(mut file) = fs::OpenOptions::new()
   46|      0|        .create(true)
   47|      0|        .append(true)
   48|      0|        .open(log_path)
   49|      0|    {
   50|      0|        let _ = file.write_all(buf.as_bytes());
   51|      0|    }
   52|      0|}
   53|       |
   54|      0|#[tauri::command]
   55|      0|pub async fn get_service_status(state: State<'_, AppState>) -> Result<ServiceStatus, String> {
   56|      0|    let flag_guard = state.watcher_flag.lock().map_err(|e| e.to_string())?;
   57|      0|    let running = flag_guard.is_some();
   58|      0|    drop(flag_guard); // Release lock early
   59|       |
   60|      0|    let uptime_seconds = if running {
   61|      0|        let start_time = state.service_start_time.lock().map_err(|e| e.to_string())?;
   62|      0|        start_time.map(|t| t.elapsed().as_secs())
   63|       |    } else {
   64|      0|        None
   65|       |    };
   66|       |
   67|      0|    Ok(ServiceStatus {
   68|      0|        running,
   69|      0|        uptime_seconds,
   70|      0|    })
   71|      0|}
   72|       |
   73|      0|pub fn internal_start_service(state: &AppState) -> Result<(), String> {
   74|      0|    let mut flag_guard = state.watcher_flag.lock().map_err(|e| e.to_string())?;
   75|       |
   76|       |    // If already running, do nothing
   77|      0|    if let Some(flag) = flag_guard.as_ref() {
   78|      0|        if flag.load(Ordering::SeqCst) {
   79|      0|            return Ok(());
   80|      0|        }
   81|      0|    }
   82|       |
   83|       |    // Create a new flag for this new thread
   84|      0|    let new_flag = Arc::new(std::sync::atomic::AtomicBool::new(true));
   85|      0|    *flag_guard = Some(new_flag.clone());
   86|       |
   87|      0|    let config = state.config.read().map_err(|e| e.to_string())?.clone();
   88|      0|    let log_path = state.recent_log_path();
   89|       |
   90|       |    // Use the *new* flag for the thread
   91|      0|    let thread_flag = new_flag.clone();
   92|      0|    let handle = thread::spawn(move || {
   93|      0|        let _ = watch_polling(&config, 5, &thread_flag, |actions| {
   94|      0|            append_to_log(&log_path, actions);
   95|      0|        });
   96|      0|    });
   97|       |
   98|      0|    let mut guard = state.watcher_handle.lock().map_err(|e| e.to_string())?;
   99|      0|    *guard = Some(handle);
  100|       |
  101|       |    // Set start time
  102|      0|    let mut time_guard = state.service_start_time.lock().map_err(|e| e.to_string())?;
  103|      0|    *time_guard = Some(std::time::Instant::now());
  104|       |
  105|      0|    Ok(())
  106|      0|}
  107|       |
  108|      0|pub fn internal_stop_service(state: &AppState) -> Result<(), String> {
  109|      0|    let mut flag_guard = state.watcher_flag.lock().map_err(|e| e.to_string())?;
  110|       |
  111|      0|    if let Some(flag) = flag_guard.take() {
  112|      0|        // Signal the thread to stop
  113|      0|        flag.store(false, Ordering::SeqCst);
  114|      0|    }
  115|       |
  116|       |    // We don't join the thread here to avoid blocking the UI,
  117|       |    // but since we've set its specific flag to false, it WILL exit
  118|       |    // on its next loop iteration (within 5 seconds).
  119|       |
  120|      0|    let mut guard = state.watcher_handle.lock().map_err(|e| e.to_string())?;
  121|      0|    *guard = None;
  122|       |
  123|      0|    let mut time_guard = state.service_start_time.lock().map_err(|e| e.to_string())?;
  124|      0|    *time_guard = None;
  125|       |
  126|      0|    Ok(())
  127|      0|}
  128|       |
  129|      0|pub fn persist_service_state(state: &AppState, enabled: bool) -> Result<(), String> {
  130|       |    {
  131|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  132|      0|        config.service_enabled = Some(enabled);
  133|       |    }
  134|       |    // Save to disk
  135|      0|    let config = state.config.read().map_err(|e| e.to_string())?;
  136|      0|    if let Ok(yaml) = serde_yaml::to_string(&*config) {
  137|      0|        std::fs::write(&state.config_path, yaml)
  138|      0|            .map_err(|e| format!("Failed to write config: {}", e))?;
  139|      0|    }
  140|      0|    Ok(())
  141|      0|}
  142|       |
  143|      0|#[tauri::command]
  144|      0|pub async fn start_service(state: State<'_, AppState>) -> Result<(), String> {
  145|      0|    persist_service_state(&state, true)?;
  146|      0|    internal_start_service(&state)
  147|      0|}
  148|       |
  149|      0|#[tauri::command]
  150|      0|pub async fn stop_service(state: State<'_, AppState>) -> Result<(), String> {
  151|      0|    persist_service_state(&state, false)?;
  152|      0|    internal_stop_service(&state)
  153|      0|}
  154|       |
  155|      0|#[tauri::command]
  156|      0|pub async fn trigger_organize_now(state: State<'_, AppState>) -> Result<usize, String> {
  157|      0|    let config = state.config.read().map_err(|e| e.to_string())?.clone();
  158|      0|    let log_path = state.recent_log_path();
  159|       |
  160|      0|    let actions = organize_once(&config).map_err(|e| format!("Organize failed: {}", e))?;
  161|       |
  162|      0|    append_to_log(&log_path, &actions);
  163|       |
  164|      0|    Ok(actions.len())
  165|      0|}
  166|       |
  167|       |#[tauri::command]
  168|      0|pub async fn get_startup_enabled() -> Result<bool, String> {
  169|       |    #[cfg(windows)]
  170|       |    {
  171|      0|        let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  172|      0|        let run_key = hkcu
  173|      0|            .open_subkey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")
  174|      0|            .map_err(|e| format!("Failed to open registry key: {}", e))?;
  175|       |
  176|      0|        match run_key.get_value::<String, _>("Harbor") {
  177|      0|            Ok(_) => Ok(true),
  178|      0|            Err(_) => Ok(false),
  179|       |        }
  180|       |    }
  181|       |
  182|       |    #[cfg(not(windows))]
  183|       |    {
  184|       |        Ok(false)
  185|       |    }
  186|      0|}
  187|       |
  188|      0|#[tauri::command]
  189|      0|pub async fn set_startup_enabled(enabled: bool) -> Result<(), String> {
  190|       |    #[cfg(windows)]
  191|       |    {
  192|      0|        let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  193|      0|        let (run_key, _) = hkcu
  194|      0|            .create_subkey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run")
  195|      0|            .map_err(|e| format!("Failed to open registry key: {}", e))?;
  196|       |
  197|      0|        if enabled {
  198|       |            // Get the path to the tray executable
  199|      0|            let exe_path = std::env::current_exe()
  200|      0|                .map_err(|e| format!("Failed to get executable path: {}", e))?;
  201|       |
  202|      0|            run_key
  203|      0|                .set_value("Harbor", &exe_path.to_string_lossy().as_ref())
  204|      0|                .map_err(|e| format!("Failed to set registry value: {}", e))?;
  205|      0|        } else {
  206|      0|            // Remove the startup entry
  207|      0|            let _ = run_key.delete_value("Harbor");
  208|      0|        }
  209|       |
  210|      0|        Ok(())
  211|       |    }
  212|       |
  213|       |    #[cfg(not(windows))]
  214|       |    {
  215|       |        Err("Startup configuration not supported on this platform".to_string())
  216|       |    }
  217|      0|}
  218|       |
  219|      0|#[tauri::command]
  220|      0|pub async fn reload_config(state: State<'_, AppState>) -> Result<(), String> {
  221|      0|    let new_config = load_downloads_config(&state.config_path)
  222|      0|        .map_err(|e| format!("Failed to reload config: {}", e))?;
  223|       |
  224|      0|    let mut config = state.config.write().map_err(|e| e.to_string())?;
  225|      0|    *config = new_config;
  226|       |
  227|      0|    Ok(())
  228|      0|}
  229|       |
  230|      0|#[tauri::command]
  231|      0|pub async fn open_config_file(state: State<'_, AppState>) -> Result<(), String> {
  232|      0|    let path = &state.config_path;
  233|       |
  234|       |    #[cfg(windows)]
  235|       |    {
  236|      0|        std::process::Command::new("cmd")
  237|      0|            .args(["/C", "start", "", path.to_string_lossy().as_ref()])
  238|      0|            .spawn()
  239|      0|            .map_err(|e| format!("Failed to open config file: {}", e))?;
  240|       |    }
  241|       |
  242|       |    #[cfg(not(windows))]
  243|       |    {
  244|       |        std::process::Command::new("xdg-open")
  245|       |            .arg(path)
  246|       |            .spawn()
  247|       |            .map_err(|e| format!("Failed to open config file: {}", e))?;
  248|       |    }
  249|       |
  250|      0|    Ok(())
  251|      0|}
  252|       |
  253|      0|#[tauri::command]
  254|      0|pub async fn open_downloads_folder(state: State<'_, AppState>) -> Result<(), String> {
  255|      0|    let config = state.config.read().map_err(|e| e.to_string())?;
  256|      0|    let path = &config.download_dir;
  257|       |
  258|       |    #[cfg(windows)]
  259|       |    {
  260|      0|        std::process::Command::new("explorer")
  261|      0|            .arg(path)
  262|      0|            .spawn()
  263|      0|            .map_err(|e| format!("Failed to open downloads folder: {}", e))?;
  264|       |    }
  265|       |
  266|       |    #[cfg(not(windows))]
  267|       |    {
  268|       |        std::process::Command::new("xdg-open")
  269|       |            .arg(path)
  270|       |            .spawn()
  271|       |            .map_err(|e| format!("Failed to open downloads folder: {}", e))?;
  272|       |    }
  273|       |
  274|      0|    Ok(())
  275|      0|}
  276|       |
  277|      0|#[tauri::command]
  278|      0|pub async fn get_config_path(state: State<'_, AppState>) -> Result<String, String> {
  279|      0|    Ok(state.config_path.to_string_lossy().to_string())
  280|      0|}
  281|       |
  282|      0|#[tauri::command]
  283|      0|pub async fn reset_to_defaults(state: State<'_, AppState>) -> Result<(), String> {
  284|      0|    let config = harbor_core::downloads::default_config();
  285|       |
  286|       |    // Save to disk
  287|      0|    if let Ok(yaml) = serde_yaml::to_string(&config) {
  288|      0|        std::fs::write(&state.config_path, yaml)
  289|      0|            .map_err(|e| format!("Failed to write config: {}", e))?;
  290|       |    } else {
  291|      0|        return Err("Failed to serialize default config".to_string());
  292|       |    }
  293|       |
  294|       |    // Update state
  295|      0|    let mut state_config = state.config.write().map_err(|e| e.to_string())?;
  296|      0|    *state_config = config;
  297|       |
  298|       |    // Restart service if running to pick up new config
  299|       |    // We can just rely on internal_start_service logic which re-reads config if we stop/start?
  300|       |    // Actually, internal_start_service reads from state.config via read lock.
  301|       |    // But verify if the running thread picks up changes?
  302|       |    // The running thread has a CLONE of the config at start.
  303|       |    // So if service is running, we MUST restart it.
  304|       |
  305|       |    // We can't access `internal_stop_service` easily if we are holding a write lock on config?
  306|       |    // No, locks are separate. global `watcher_flag` and `watcher_handle` vs `config` RwLock.
  307|       |
  308|       |    // But we are holding `state.config` write lock right now.
  309|       |    // `internal_start_service` needs `state.config` read lock.
  310|       |    // So we must drop our write lock before calling any service functions.
  311|      0|    drop(state_config);
  312|       |
  313|       |    // Stop and start service to apply changes
  314|      0|    let _ = internal_stop_service(&state);
  315|      0|    let _ = internal_start_service(&state);
  316|       |
  317|      0|    Ok(())
  318|      0|}
  319|       |
  320|      0|#[tauri::command]
  321|      0|pub async fn get_tutorial_completed(state: State<'_, AppState>) -> Result<bool, String> {
  322|      0|    let config = state.config.read().map_err(|e| e.to_string())?;
  323|       |    // If None, we treat it as completed (true) for existing users who upgrade,
  324|       |    // but default_config sets it to Some(false) for new users.
  325|       |    // However, if we just upgraded and it's missing from yaml, it will be None.
  326|      0|    Ok(config.tutorial_completed.unwrap_or(true))
  327|      0|}
  328|       |
  329|      0|#[tauri::command]
  330|      0|pub async fn set_tutorial_completed(
  331|      0|    state: State<'_, AppState>,
  332|      0|    completed: bool,
  333|      0|) -> Result<(), String> {
  334|       |    {
  335|      0|        let mut config = state.config.write().map_err(|e| e.to_string())?;
  336|      0|        config.tutorial_completed = Some(completed);
  337|       |    }
  338|       |
  339|       |    // Save to disk
  340|      0|    let config = state.config.read().map_err(|e| e.to_string())?;
  341|      0|    if let Ok(yaml) = serde_yaml::to_string(&*config) {
  342|      0|        std::fs::write(&state.config_path, yaml)
  343|      0|            .map_err(|e| format!("Failed to write config: {}", e))?;
  344|       |    } else {
  345|      0|        return Err("Failed to serialize config".to_string());
  346|       |    }
  347|       |
  348|      0|    Ok(())
  349|      0|}

C:\Users\eduard\Documents\github\Harbor\crates\tauri-app\src\main.rs:
    1|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]
    2|       |
    3|       |mod commands;
    4|       |mod state;
    5|       |
    6|       |use harbor_core::downloads::{default_config, load_downloads_config};
    7|       |
    8|       |use state::AppState;
    9|       |use std::path::PathBuf;
   10|       |use tauri::{Emitter, Manager};
   11|       |
   12|      0|fn local_appdata_harbor() -> PathBuf {
   13|      0|    std::env::var("LOCALAPPDATA")
   14|      0|        .map(|p| PathBuf::from(p).join("Harbor"))
   15|      0|        .unwrap_or(PathBuf::from("C:\\Harbor"))
   16|      0|}
   17|       |
   18|      0|fn main() {
   19|      0|    let harbor_dir = local_appdata_harbor();
   20|      0|    let _ = std::fs::create_dir_all(&harbor_dir);
   21|       |
   22|      0|    let cfg_path = harbor_dir.join("harbor.downloads.yaml");
   23|       |
   24|       |    // If config doesn't exist, try to copy from default template or create default
   25|      0|    if !cfg_path.exists() {
   26|      0|        let default_config_path = harbor_dir.join("harbor.downloads.yaml.default");
   27|      0|        if default_config_path.exists() {
   28|      0|            let _ = std::fs::copy(&default_config_path, &cfg_path);
   29|      0|        } else {
   30|       |            // Create default config
   31|      0|            let config = default_config();
   32|      0|            if let Ok(yaml) = serde_yaml::to_string(&config) {
   33|      0|                let _ = std::fs::write(&cfg_path, yaml);
   34|      0|            }
   35|       |        }
   36|      0|    }
   37|       |
   38|      0|    let config = if cfg_path.exists() {
   39|      0|        load_downloads_config(&cfg_path).unwrap_or_else(|_| default_config())
   40|       |    } else {
   41|      0|        default_config()
   42|       |    };
   43|       |
   44|       |    // Start service if enabled in config (Default: true for new users)
   45|      0|    let service_enabled = config.service_enabled.unwrap_or(true);
   46|       |
   47|      0|    let app_state = AppState::new(cfg_path, config);
   48|       |
   49|      0|    if service_enabled {
   50|      0|        let _ = commands::settings::internal_start_service(&app_state);
   51|      0|    }
   52|       |
   53|      0|    tauri::Builder::default()
   54|      0|        .plugin(tauri_plugin_shell::init())
   55|      0|        .plugin(tauri_plugin_dialog::init())
   56|      0|        .plugin(tauri_plugin_notification::init())
   57|      0|        .plugin(tauri_plugin_single_instance::init(|app, _args, _cwd| {
   58|      0|            if let Some(window) = app.get_webview_window("main") {
   59|      0|                let _ = window.show();
   60|      0|                let _ = window.set_focus();
   61|      0|            }
   62|      0|        }))
   63|      0|        .plugin(tauri_plugin_autostart::init(
   64|      0|            tauri_plugin_autostart::MacosLauncher::LaunchAgent,
   65|      0|            Some(vec!["--minimized"]),
   66|       |        ))
   67|      0|        .manage(app_state)
   68|      0|        .invoke_handler(tauri::generate_handler![
   69|       |            // Rules commands
   70|       |            commands::get_rules,
   71|       |            commands::create_rule,
   72|       |            commands::update_rule,
   73|       |            commands::delete_rule,
   74|       |            commands::toggle_rule,
   75|       |            commands::reorder_rules,
   76|       |            commands::get_download_dir,
   77|       |            // Activity commands
   78|       |            commands::get_activity_logs,
   79|       |            commands::get_activity_stats,
   80|       |            commands::clear_activity_logs,
   81|       |            // Settings commands
   82|       |            commands::get_service_status,
   83|       |            commands::start_service,
   84|       |            commands::stop_service,
   85|       |            commands::trigger_organize_now,
   86|       |            commands::get_startup_enabled,
   87|       |            commands::set_startup_enabled,
   88|       |            commands::reload_config,
   89|       |            commands::open_config_file,
   90|       |            commands::open_downloads_folder,
   91|       |            commands::get_config_path,
   92|       |            commands::reset_to_defaults,
   93|       |            commands::get_tutorial_completed,
   94|       |            commands::set_tutorial_completed,
   95|       |        ])
   96|      0|        .on_window_event(|window, event| {
   97|      0|            if let tauri::WindowEvent::CloseRequested { api, .. } = event {
   98|      0|                window.hide().unwrap();
   99|      0|                api.prevent_close();
  100|      0|            }
  101|      0|        })
  102|      0|        .setup(move |app| {
  103|       |            use tauri::image::Image;
  104|       |            use tauri::menu::{CheckMenuItemBuilder, MenuBuilder, MenuItemBuilder};
  105|       |            use tauri::tray::{MouseButton, TrayIconBuilder, TrayIconEvent};
  106|       |            use tauri_plugin_autostart::ManagerExt;
  107|       |
  108|       |            // --- AutoStart Logic ---
  109|      0|            let autostart_manager = app.autolaunch();
  110|      0|            if !autostart_manager.is_enabled().unwrap_or(false) {
  111|      0|                let _ = autostart_manager.enable();
  112|      0|            }
  113|       |
  114|       |            // --- Smart Visibility Logic ---
  115|      0|            let args: Vec<String> = std::env::args().collect();
  116|      0|            let is_minimized_launch = args.contains(&"--minimized".to_string());
  117|       |
  118|      0|            if let Some(window) = app.get_webview_window("main") {
  119|      0|                if is_minimized_launch {
  120|      0|                    let _ = window.hide();
  121|      0|                } else {
  122|      0|                    let _ = window.show();
  123|      0|                    let _ = window.set_focus();
  124|      0|                }
  125|      0|            }
  126|       |
  127|       |            // Load _h icon
  128|      0|            let icon_bytes = include_bytes!("../../../assets/icon_h.ico");
  129|      0|            let tray_icon = Image::from_bytes(icon_bytes).expect("Failed to load tray icon");
  130|       |
  131|       |            // Build Tray Menu
  132|      0|            let status_on = CheckMenuItemBuilder::new("Service On")
  133|      0|                .id("service_on")
  134|      0|                .checked(service_enabled) // Default is based on config
  135|      0|                .build(app)?;
  136|       |
  137|      0|            let status_off = CheckMenuItemBuilder::new("Service Off")
  138|      0|                .id("service_off")
  139|      0|                .checked(!service_enabled)
  140|      0|                .build(app)?;
  141|       |
  142|      0|            let organize_now = MenuItemBuilder::new("Organize Now")
  143|      0|                .id("organize")
  144|      0|                .build(app)?;
  145|       |
  146|      0|            let open_downloads = MenuItemBuilder::new("Open Downloads")
  147|      0|                .id("open_downloads")
  148|      0|                .build(app)?;
  149|      0|            let open_rules = MenuItemBuilder::new("Open Rules")
  150|      0|                .id("open_rules")
  151|      0|                .build(app)?; // Will open app at rules
  152|      0|            let open_activity = MenuItemBuilder::new("Open Recent Moves")
  153|      0|                .id("open_activity")
  154|      0|                .build(app)?;
  155|      0|            let open_settings = MenuItemBuilder::new("Settings")
  156|      0|                .id("open_settings")
  157|      0|                .build(app)?;
  158|       |
  159|      0|            let quit_i = MenuItemBuilder::new("Quit").id("quit").build(app)?;
  160|       |
  161|      0|            let menu = MenuBuilder::new(app)
  162|      0|                .items(&[
  163|      0|                    &status_on,
  164|      0|                    &status_off,
  165|      0|                    &tauri::menu::PredefinedMenuItem::separator(app)?,
  166|      0|                    &organize_now,
  167|      0|                    &tauri::menu::PredefinedMenuItem::separator(app)?,
  168|      0|                    &open_downloads,
  169|      0|                    &open_rules,
  170|      0|                    &open_activity,
  171|      0|                    &open_settings,
  172|      0|                    &tauri::menu::PredefinedMenuItem::separator(app)?,
  173|      0|                    &quit_i,
  174|       |                ])
  175|      0|                .build()?;
  176|       |
  177|      0|            let _tray = TrayIconBuilder::with_id("tray")
  178|      0|                .icon(tray_icon)
  179|      0|                .menu(&menu)
  180|      0|                .show_menu_on_left_click(false)
  181|      0|                .on_tray_icon_event(|tray, event| {
  182|       |                    if let TrayIconEvent::Click {
  183|       |                        button: MouseButton::Left,
  184|       |                        ..
  185|      0|                    } = event
  186|       |                    {
  187|      0|                        let app = tray.app_handle();
  188|      0|                        if let Some(window) = app.get_webview_window("main") {
  189|      0|                            let _ = window.show();
  190|      0|                            let _ = window.set_focus();
  191|      0|                        }
  192|      0|                    }
  193|      0|                })
  194|      0|                .on_menu_event(move |app, event| match event.id.as_ref() {
  195|      0|                    "quit" => {
  196|      0|                        app.exit(0);
  197|      0|                    }
  198|      0|                    "service_on" => {
  199|      0|                        let state: tauri::State<AppState> = app.state();
  200|      0|                        let _ = commands::settings::persist_service_state(&state, true);
  201|      0|                        let _ = commands::settings::internal_start_service(&state);
  202|      0|                        let _ = status_on.set_checked(true);
  203|      0|                        let _ = status_off.set_checked(false);
  204|      0|                        // Force update UI if open? Not easy from here, UI polls status.
  205|      0|                    }
  206|      0|                    "service_off" => {
  207|      0|                        let state: tauri::State<AppState> = app.state();
  208|      0|                        let _ = commands::settings::persist_service_state(&state, false);
  209|      0|                        let _ = commands::settings::internal_stop_service(&state);
  210|      0|                        let _ = status_on.set_checked(false);
  211|      0|                        let _ = status_off.set_checked(true);
  212|      0|                    }
  213|      0|                    "organize" => {
  214|      0|                        let app_handle = app.clone();
  215|      0|                        tauri::async_runtime::spawn(async move {
  216|      0|                            let state: tauri::State<AppState> = app_handle.state();
  217|      0|                            let _ = commands::trigger_organize_now(state).await;
  218|      0|                        });
  219|       |                    }
  220|      0|                    "open_downloads" => {
  221|      0|                        let app_handle = app.clone();
  222|      0|                        tauri::async_runtime::spawn(async move {
  223|      0|                            let state: tauri::State<AppState> = app_handle.state();
  224|      0|                            let _ = commands::open_downloads_folder(state).await;
  225|      0|                        });
  226|       |                    }
  227|      0|                    "open_rules" => {
  228|      0|                        if let Some(window) = app.get_webview_window("main") {
  229|      0|                            let _ = window.show();
  230|      0|                            let _ = window.set_focus();
  231|      0|                            let _ = window.eval("window.location.href = '/rules'"); // Simple way to nav? Or use an event.
  232|      0|                                                                                    // Better: emit event to frontend router.
  233|      0|                            let _ = window.emit("navigate", "/rules");
  234|      0|                        }
  235|       |                    }
  236|      0|                    "open_activity" => {
  237|      0|                        if let Some(window) = app.get_webview_window("main") {
  238|      0|                            let _ = window.show();
  239|      0|                            let _ = window.set_focus();
  240|      0|                            let _ = window.emit("navigate", "/");
  241|      0|                        }
  242|       |                    }
  243|      0|                    "open_settings" => {
  244|      0|                        if let Some(window) = app.get_webview_window("main") {
  245|      0|                            let _ = window.show();
  246|      0|                            let _ = window.set_focus();
  247|      0|                            let _ = window.emit("navigate", "/settings");
  248|      0|                        }
  249|       |                    }
  250|      0|                    _ => {}
  251|      0|                })
  252|      0|                .build(app)?;
  253|       |
  254|      0|            Ok(())
  255|      0|        })
  256|      0|        .run(tauri::generate_context!())
  257|      0|        .expect("error while running tauri application");
  258|      0|}

C:\Users\eduard\Documents\github\Harbor\crates\tauri-app\src\state.rs:
    1|       |use harbor_core::downloads::DownloadsConfig;
    2|       |use std::path::PathBuf;
    3|       |use std::sync::atomic::AtomicBool;
    4|       |use std::sync::{Arc, Mutex, RwLock};
    5|       |use std::thread::JoinHandle;
    6|       |
    7|       |/// Application state managed by Tauri
    8|       |pub struct AppState {
    9|       |    /// Path to the configuration file
   10|       |    pub config_path: PathBuf,
   11|       |    /// Valid flag for the *current* watcher thread.
   12|       |    /// When the service stops or restarts, we set the old flag to false
   13|       |    /// and create a new one for the new thread.
   14|       |    pub watcher_flag: Arc<Mutex<Option<Arc<AtomicBool>>>>,
   15|       |    /// Current configuration (cached)
   16|       |    pub config: Arc<RwLock<DownloadsConfig>>,
   17|       |    /// Handle to the watcher thread
   18|       |    pub watcher_handle: Arc<Mutex<Option<JoinHandle<()>>>>,
   19|       |    /// Timestamp when the service was started
   20|       |    pub service_start_time: Arc<Mutex<Option<std::time::Instant>>>,
   21|       |}
   22|       |
   23|       |impl AppState {
   24|      0|    pub fn new(config_path: PathBuf, config: DownloadsConfig) -> Self {
   25|      0|        Self {
   26|      0|            config_path,
   27|      0|            watcher_flag: Arc::new(Mutex::new(None)),
   28|      0|            config: Arc::new(RwLock::new(config)),
   29|      0|            watcher_handle: Arc::new(Mutex::new(None)),
   30|      0|            service_start_time: Arc::new(Mutex::new(None)),
   31|      0|        }
   32|      0|    }
   33|       |
   34|       |    /// Get the path to the recent moves log
   35|      0|    pub fn recent_log_path(&self) -> PathBuf {
   36|      0|        self.config_path
   37|      0|            .parent()
   38|      0|            .unwrap_or(&self.config_path)
   39|      0|            .join("recent_moves.log")
   40|      0|    }
   41|       |}

C:\Users\eduard\Documents\github\Harbor\crates\tray\src\main.rs:
    1|       |use crate::windows::utils::SingleInstance;
    2|       |use anyhow::Result;
    3|       |use harbor_core::downloads::{
    4|       |    cleanup_old_symlinks, load_downloads_config, organize_once, watch_polling, DownloadsConfig,
    5|       |    OrganizeResult,
    6|       |};
    7|       |use native_windows_gui as nwg;
    8|       |use std::path::{Path, PathBuf};
    9|       |use std::sync::atomic::{AtomicBool, Ordering};
   10|       |use std::sync::{Arc, Mutex};
   11|       |use std::thread;
   12|       |
   13|       |mod windows {
   14|       |    pub mod utils {
   15|       |        use anyhow::{anyhow, Result};
   16|       |        use windows::core::PCWSTR;
   17|       |        use windows::Win32::Foundation::{CloseHandle, GetLastError, ERROR_ALREADY_EXISTS, HANDLE};
   18|       |        use windows::Win32::System::Threading::CreateMutexW;
   19|       |
   20|       |        pub struct SingleInstance {
   21|       |            handle: HANDLE,
   22|       |        }
   23|       |
   24|       |        impl SingleInstance {
   25|      3|            pub fn new(name: &str) -> Result<Self> {
   26|      3|                let wide_name: Vec<u16> = name.encode_utf16().chain(std::iter::once(0)).collect();
   27|       |
   28|       |                // SAFETY: We are calling a Windows API function with a valid pointer to a null-terminated wide string.
   29|      3|                let handle = unsafe { CreateMutexW(None, true, PCWSTR(wide_name.as_ptr())) }?;
                                                                                                          ^0
   30|       |
   31|       |                // SAFETY: We call GetLastError immediately after CreateMutexW
   32|      3|                let error = unsafe { GetLastError() };
   33|       |
   34|      3|                if error == ERROR_ALREADY_EXISTS {
   35|       |                    // Close the handle to the existing mutex so we don't leak a reference
   36|      1|                    unsafe {
   37|      1|                        let _ = CloseHandle(handle);
   38|      1|                    }
   39|      1|                    return Err(anyhow!("Another instance is already running"));
   40|      2|                }
   41|       |
   42|      2|                Ok(Self { handle })
   43|      3|            }
   44|       |        }
   45|       |
   46|       |        impl Drop for SingleInstance {
   47|      2|            fn drop(&mut self) {
   48|      2|                if !self.handle.is_invalid() {
   49|      2|                    unsafe {
   50|      2|                        let _ = CloseHandle(self.handle);
   51|      2|                    }
   52|      0|                }
   53|      2|            }
   54|       |        }
   55|       |    }
   56|       |}
   57|       |
   58|       |pub struct TrayLogic {
   59|       |    pub config: Arc<DownloadsConfig>, // Made public for testing access if needed
   60|       |    watching: Arc<AtomicBool>,
   61|       |    handle: Arc<Mutex<Option<thread::JoinHandle<()>>>>,
   62|       |}
   63|       |
   64|       |impl TrayLogic {
   65|      3|    pub fn new(config: DownloadsConfig) -> Self {
   66|      3|        Self {
   67|      3|            config: Arc::new(config),
   68|      3|            watching: Arc::new(AtomicBool::new(false)),
   69|      3|            handle: Arc::new(Mutex::new(None)),
   70|      3|        }
   71|      3|    }
   72|       |
   73|      1|    pub fn start_watching(&self) {
   74|      1|        if self.watching.swap(true, Ordering::SeqCst) {
   75|      0|            return;
   76|      1|        }
   77|       |
   78|      1|        let cfg = self.config.clone();
   79|      1|        let w = self.watching.clone();
   80|       |
   81|      1|        let h = thread::spawn(move || {
   82|      1|            let _ = watch_polling(&cfg, 5, &w, |actions| {
                                                                       ^0
   83|       |                // We can't update UI from here directly without a handle/sender.
   84|       |                // For now, valid logic is to append to recent log.
   85|      0|                TrayLogic::append_recent(actions);
   86|      0|            });
   87|      1|        });
   88|       |
   89|      1|        let mut guard = self.handle.lock().unwrap();
   90|      1|        *guard = Some(h);
   91|      1|    }
   92|       |
   93|      1|    pub fn stop_watching(&self) {
   94|      1|        self.watching.store(false, Ordering::SeqCst);
   95|      1|        let mut guard = self.handle.lock().unwrap();
   96|      1|        if let Some(h) = guard.take() {
   97|      1|            // Unpark or wait? watch_polling checks atomic every 5s or on event.
   98|      1|            // We just let it finish.
   99|      1|            // On Windows we cannot easily interrupt the directory watcher.
  100|      1|            // But verify thread usage:
  101|      1|            #[allow(clippy::disallowed_methods)]
  102|      1|            let _ = h.thread().id();
  103|      1|        }
                      ^0
  104|      1|    }
  105|       |
  106|      1|    pub fn organize_now(&self) -> Result<Vec<OrganizeResult>> {
  107|      1|        let actions = organize_once(&self.config)?;
                                                               ^0
  108|      1|        TrayLogic::append_recent(&actions);
  109|      1|        Ok(actions)
  110|      1|    }
  111|       |
  112|      1|    pub fn cleanup_old_symlinks(&self) -> Result<usize> {
  113|      1|        let count = cleanup_old_symlinks(&self.config)?;
                                                                    ^0
  114|      1|        if count > 0 {
  115|      0|            let _ = std::fs::OpenOptions::new()
  116|      0|                .create(true)
  117|      0|                .append(true)
  118|      0|                .open(Self::recent_log_path())
  119|      0|                .and_then(|mut f| {
  120|       |                    use std::io::Write;
  121|      0|                    writeln!(f, "Startup: Cleaned up {} old symlink(s)", count)
  122|      0|                });
  123|      1|        }
  124|      1|        Ok(count)
  125|      1|    }
  126|       |
  127|      1|    fn local_appdata_harbor() -> PathBuf {
  128|      1|        std::env::var("LOCALAPPDATA")
  129|      1|            .map(|p| PathBuf::from(p).join("Harbor"))
  130|      1|            .unwrap_or(PathBuf::from("C:\\Harbor"))
  131|      1|    }
  132|       |
  133|      1|    fn recent_log_path() -> PathBuf {
  134|      1|        Self::local_appdata_harbor().join("recent_moves.log")
  135|      1|    }
  136|       |
  137|      1|    fn append_recent(actions: &[OrganizeResult]) {
  138|      1|        if actions.is_empty() {
  139|      0|            return;
  140|      1|        }
  141|      1|        let log_path = Self::recent_log_path();
  142|       |
  143|       |        // Ensure directory exists
  144|      1|        if let Some(parent) = log_path.parent() {
  145|      1|            let _ = std::fs::create_dir_all(parent);
  146|      1|        }
                      ^0
  147|       |
  148|      1|        if let Ok(mut file) = std::fs::OpenOptions::new()
  149|      1|            .create(true)
  150|      1|            .append(true)
  151|      1|            .open(log_path)
  152|       |        {
  153|       |            use std::io::Write;
  154|      2|            for (from, to, rule, _) in actions {
                               ^1    ^1  ^1
  155|      1|                let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
  156|      1|                let _ = writeln!(
  157|      1|                    file,
  158|      1|                    "[{}] Moved {} -> {} (Rule: {})",
  159|      1|                    timestamp,
  160|      1|                    from.file_name().unwrap_or_default().to_string_lossy(),
  161|      1|                    to.display(),
  162|      1|                    rule
  163|      1|                );
  164|      1|            }
  165|      0|        }
  166|      1|    }
  167|       |}
  168|       |
  169|       |// Extracted for testing
  170|      3|pub fn load_initial_config(config_path: &Path) -> Result<DownloadsConfig> {
  171|       |    // If config doesn't exist, try to copy from default template
  172|      3|    if !config_path.exists() {
  173|       |        // Look for .default in the same directory
  174|      2|        let default_config_path = config_path.with_extension("yaml.default");
  175|      2|        if default_config_path.exists() {
  176|      1|            // Copy the default config to the active config
  177|      1|            let _ = std::fs::copy(&default_config_path, config_path);
  178|      1|        }
  179|      1|    }
  180|       |
  181|      3|    if config_path.exists() {
  182|      2|        load_downloads_config(config_path)
  183|       |    } else {
  184|       |        // Use core default config
  185|      1|        Ok(harbor_core::downloads::default_config())
  186|       |    }
  187|      3|}
  188|       |
  189|       |#[derive(Default)]
  190|       |struct TrayState {
  191|       |    window: nwg::Window,
  192|       |    tray: nwg::TrayNotification,
  193|       |    tray_menu: nwg::Menu,
  194|       |    item_start: nwg::MenuItem,
  195|       |    item_stop: nwg::MenuItem,
  196|       |    item_organize: nwg::MenuItem,
  197|       |    item_open_downloads: nwg::MenuItem,
  198|       |    item_open_cfg: nwg::MenuItem,
  199|       |    item_open_recent: nwg::MenuItem,
  200|       |    item_exit: nwg::MenuItem,
  201|       |}
  202|       |
  203|      0|fn show_menu(ui: &TrayState) {
  204|      0|    let (x, y) = nwg::GlobalCursor::position();
  205|      0|    ui.tray_menu.popup(x, y);
  206|      0|}
  207|       |
  208|      0|fn open_folder(path: &Path) {
  209|      0|    if cfg!(windows) {
  210|      0|        let _ = std::process::Command::new("explorer").arg(path).spawn();
  211|      0|    }
  212|      0|}
  213|       |
  214|      0|fn open_config(path: &Path) {
  215|      0|    if cfg!(windows) {
  216|      0|        // Use default editor
  217|      0|        let _ = std::process::Command::new("cmd")
  218|      0|            .args(["/C", "start", "", path.to_str().unwrap_or("")])
  219|      0|            .spawn();
  220|      0|    }
  221|      0|}
  222|       |
  223|      0|fn main() -> Result<()> {
  224|       |    // Ensure only one instance of Harbor is running
  225|      0|    let _instance = SingleInstance::new("Harbor-Tray-Instance")?;
  226|       |
  227|      0|    nwg::init()?;
  228|       |
  229|      0|    let cfg_path = TrayLogic::local_appdata_harbor().join("harbor.downloads.yaml");
  230|       |
  231|       |    // Load config using refactored function
  232|      0|    let cfg = load_initial_config(&cfg_path)?;
  233|       |
  234|      0|    let app_logic = Arc::new(TrayLogic::new(cfg));
  235|       |
  236|      0|    let mut ui = TrayState::default();
  237|       |
  238|       |    // We modify ui fields in place
  239|      0|    let _window = nwg::Window::builder()
  240|      0|        .flags(nwg::WindowFlags::POPUP)
  241|      0|        .size((300, 300))
  242|      0|        .title("Harbor Tray")
  243|      0|        .build(&mut ui.window)?;
  244|       |
  245|       |    // We need to load icon from file or resource
  246|      0|    let mut icon = nwg::Icon::default();
  247|       |
  248|       |    // Try to find icon
  249|      0|    let icon_path = std::env::current_exe()
  250|      0|        .ok()
  251|      0|        .and_then(|p| p.parent().map(|d| d.join("icon_h.ico")))
  252|      0|        .unwrap_or(PathBuf::from("icon_h.ico"));
  253|       |
  254|      0|    if icon_path.exists() {
  255|      0|        let _ = nwg::Icon::builder()
  256|      0|            .source_file(Some(icon_path.to_str().unwrap()))
  257|      0|            .build(&mut icon);
  258|      0|    }
  259|       |
  260|      0|    nwg::TrayNotification::builder()
  261|      0|        .parent(&ui.window)
  262|      0|        .icon(Some(&icon))
  263|      0|        .tip(Some("Harbor"))
  264|      0|        .build(&mut ui.tray)?;
  265|       |
  266|      0|    nwg::Menu::builder()
  267|      0|        .popup(true)
  268|      0|        .parent(&ui.window)
  269|      0|        .build(&mut ui.tray_menu)?;
  270|       |
  271|      0|    nwg::MenuItem::builder()
  272|      0|        .text("Start Watching")
  273|      0|        .parent(&ui.tray_menu)
  274|      0|        .build(&mut ui.item_start)?;
  275|       |
  276|      0|    nwg::MenuItem::builder()
  277|      0|        .text("Stop Watching")
  278|      0|        .check(false)
  279|      0|        .parent(&ui.tray_menu)
  280|      0|        .build(&mut ui.item_stop)?;
  281|       |
  282|      0|    nwg::MenuItem::builder()
  283|      0|        .text("Organize Now")
  284|      0|        .parent(&ui.tray_menu)
  285|      0|        .build(&mut ui.item_organize)?;
  286|       |
  287|      0|    nwg::MenuItem::builder()
  288|      0|        .text("Open Downloads")
  289|      0|        .parent(&ui.tray_menu)
  290|      0|        .build(&mut ui.item_open_downloads)?;
  291|       |
  292|      0|    nwg::MenuItem::builder()
  293|      0|        .text("Open Config")
  294|      0|        .parent(&ui.tray_menu)
  295|      0|        .build(&mut ui.item_open_cfg)?;
  296|       |
  297|      0|    nwg::MenuItem::builder()
  298|      0|        .text("Open Recent Moves")
  299|      0|        .parent(&ui.tray_menu)
  300|      0|        .build(&mut ui.item_open_recent)?;
  301|       |
  302|      0|    nwg::MenuItem::builder()
  303|      0|        .text("Exit")
  304|      0|        .parent(&ui.tray_menu)
  305|      0|        .build(&mut ui.item_exit)?;
  306|       |
  307|      0|    let ui_ref = std::rc::Rc::new(ui);
  308|      0|    let ui_weak = std::rc::Rc::downgrade(&ui_ref);
  309|      0|    let cfg_open_path = cfg_path.clone();
  310|      0|    let downloads_dir = PathBuf::from(&cfg_open_path)
  311|      0|        .parent()
  312|      0|        .map(|_| PathBuf::from(&app_logic.config.download_dir))
  313|      0|        .unwrap_or(PathBuf::from(&app_logic.config.download_dir));
  314|       |
  315|      0|    let logic_c = app_logic.clone();
  316|       |
  317|      0|    let handler = move |evt, _evt_data, handle| {
  318|      0|        if let Some(ui) = ui_weak.upgrade() {
  319|      0|            match evt {
  320|       |                nwg::Event::OnContextMenu => {
  321|      0|                    if handle == ui.tray {
  322|      0|                        show_menu(&ui);
  323|      0|                    }
  324|       |                }
  325|       |                nwg::Event::OnMenuItemSelected => {
  326|      0|                    if handle == ui.item_start {
  327|      0|                        logic_c.start_watching();
  328|      0|                    } else if handle == ui.item_stop {
  329|      0|                        logic_c.stop_watching();
  330|      0|                    } else if handle == ui.item_organize {
  331|      0|                        if let Ok(actions) = logic_c.organize_now() {
  332|      0|                            if !actions.is_empty() {
  333|      0|                                ui.tray.show(
  334|      0|                                    &format!("Moved {} file(s)", actions.len()),
  335|      0|                                    Some("Harbor"),
  336|      0|                                    Some(nwg::TrayNotificationFlags::INFO_ICON),
  337|      0|                                    None,
  338|      0|                                );
  339|      0|                            }
  340|      0|                        }
  341|      0|                    } else if handle == ui.item_open_downloads {
  342|      0|                        open_folder(&downloads_dir);
  343|      0|                    } else if handle == ui.item_open_cfg {
  344|      0|                        open_config(&cfg_open_path);
  345|      0|                    } else if handle == ui.item_open_recent {
  346|      0|                        let p = TrayLogic::recent_log_path();
  347|      0|                        if !p.exists() {
  348|      0|                            if let Some(parent) = p.parent() {
  349|      0|                                let _ = std::fs::create_dir_all(parent);
  350|      0|                            }
  351|      0|                            let _ = std::fs::write(&p, "Recent Moves Log\n----------------\n");
  352|      0|                        }
  353|      0|                        open_config(&p);
  354|      0|                    } else if handle == ui.item_exit {
  355|      0|                        nwg::stop_thread_dispatch();
  356|      0|                    }
  357|       |                }
  358|      0|                _ => {}
  359|       |            }
  360|      0|        }
  361|      0|    };
  362|      0|    let _eh = nwg::full_bind_event_handler(&ui_ref.window.handle, handler);
  363|       |
  364|       |    // Cleanup old symlinks on startup
  365|      0|    let _ = app_logic.cleanup_old_symlinks();
  366|       |
  367|      0|    app_logic.start_watching();
  368|       |
  369|      0|    nwg::dispatch_thread_events();
  370|      0|    Ok(())
  371|      0|}
  372|       |
  373|       |#[cfg(test)]
  374|       |mod tests {
  375|       |    use super::*;
  376|       |    use crate::windows::utils::SingleInstance;
  377|       |    use tempfile::tempdir;
  378|       |
  379|       |    #[test]
  380|      1|    fn test_tray_logic_struct() {
  381|      1|        let cfg = DownloadsConfig {
  382|      1|            download_dir: ".".to_string(),
  383|      1|            rules: vec![],
  384|      1|            min_age_secs: Some(0),
  385|      1|            tutorial_completed: None,
  386|      1|            service_enabled: None,
  387|      1|        };
  388|      1|        let logic = TrayLogic::new(cfg);
  389|      1|        assert!(!logic.watching.load(Ordering::SeqCst));
  390|       |
  391|      1|        logic.start_watching();
  392|      1|        assert!(logic.watching.load(Ordering::SeqCst));
  393|       |
  394|      1|        logic.stop_watching();
  395|      1|        assert!(!logic.watching.load(Ordering::SeqCst));
  396|      1|    }
  397|       |
  398|       |    #[test]
  399|      1|    fn test_organize_now_calls_organize() {
  400|       |        // Setup a temp dir
  401|      1|        let tmp = tempdir().unwrap();
  402|      1|        let dl_dir = tmp.path().join("DL");
  403|      1|        std::fs::create_dir(&dl_dir).unwrap();
  404|      1|        let target = tmp.path().join("Target");
  405|       |
  406|       |        use harbor_core::types::Rule;
  407|       |
  408|      1|        let rule = Rule {
  409|      1|            name: "test".to_string(),
  410|       |            extensions: Some(
  411|      1|                vec!["txt".to_string()]
  412|      1|                    .iter()
  413|      1|                    .map(|s| s.to_string())
  414|      1|                    .collect(),
  415|       |            ),
  416|      1|            pattern: None,
  417|      1|            min_size_bytes: None,
  418|      1|            max_size_bytes: None,
  419|      1|            target_dir: target.to_str().unwrap().to_string(),
  420|      1|            create_symlink: None,
  421|      1|            enabled: Some(true),
  422|       |        };
  423|       |
  424|      1|        let cfg = DownloadsConfig {
  425|      1|            download_dir: dl_dir.to_str().unwrap().to_string(),
  426|      1|            rules: vec![rule],
  427|      1|            min_age_secs: Some(0),
  428|      1|            tutorial_completed: None,
  429|      1|            service_enabled: None,
  430|      1|        };
  431|       |
  432|      1|        let logic = TrayLogic::new(cfg);
  433|       |
  434|       |        // Create file
  435|      1|        std::fs::write(dl_dir.join("test.txt"), "foo").unwrap();
  436|       |
  437|       |        // ACT
  438|      1|        let res = logic.organize_now();
  439|      1|        assert!(res.is_ok());
  440|      1|        let actions = res.unwrap();
  441|      1|        assert_eq!(actions.len(), 1);
  442|      1|        assert!(target.join("test.txt").exists());
  443|      1|    }
  444|       |
  445|       |    #[test]
  446|      1|    fn test_cleanup_calls() {
  447|      1|        let cfg = DownloadsConfig {
  448|      1|            download_dir: ".".to_string(),
  449|      1|            rules: vec![],
  450|      1|            min_age_secs: Some(0),
  451|      1|            tutorial_completed: None,
  452|      1|            service_enabled: None,
  453|      1|        };
  454|      1|        let logic = TrayLogic::new(cfg);
  455|      1|        assert!(logic.cleanup_old_symlinks().is_ok());
  456|      1|    }
  457|       |
  458|       |    #[test]
  459|      1|    fn test_load_initial_config() {
  460|      1|        let tmp = tempdir().unwrap();
  461|      1|        let cfg_path = tmp.path().join("config.yaml");
  462|       |
  463|       |        // 1. Not exists -> default
  464|      1|        let cfg = load_initial_config(&cfg_path).unwrap();
  465|       |
  466|       |        // We know default config uses "Downloads"
  467|      1|        if cfg!(windows) {
  468|      1|            assert!(cfg.download_dir.contains("Downloads"));
  469|      0|        }
  470|       |
  471|       |        // 2. Exists -> load
  472|      1|        let content = "download_dir: \"test_dir\"\nrules: []";
  473|      1|        std::fs::write(&cfg_path, content).unwrap();
  474|      1|        let cfg = load_initial_config(&cfg_path).unwrap();
  475|      1|        assert_eq!(cfg.download_dir, "test_dir");
  476|       |
  477|       |        // 3. Default file exists (and config does not) -> copy
  478|      1|        std::fs::remove_file(&cfg_path).unwrap();
  479|      1|        let default_path = tmp.path().join("config.yaml.default");
  480|      1|        std::fs::write(
  481|      1|            &default_path,
  482|       |            "download_dir: \"default_from_file\"\nrules: []",
  483|       |        )
  484|      1|        .unwrap();
  485|       |
  486|      1|        let cfg = load_initial_config(&cfg_path).unwrap();
  487|      1|        assert_eq!(cfg.download_dir, "default_from_file");
  488|      1|        assert!(cfg_path.exists());
  489|      1|    }
  490|       |
  491|       |    #[cfg(windows)]
  492|       |    #[test]
  493|      1|    fn test_single_instance() {
  494|       |        // Use a random name to avoid conflict with running instance
  495|      1|        let name = format!(
  496|      1|            "HarborTestMutex_{}",
  497|      1|            std::time::SystemTime::now()
  498|      1|                .duration_since(std::time::UNIX_EPOCH)
  499|      1|                .unwrap()
  500|      1|                .as_nanos()
  501|       |        );
  502|      1|        let inst1 = SingleInstance::new(&name);
  503|      1|        assert!(inst1.is_ok());
  504|       |
  505|      1|        let inst2 = SingleInstance::new(&name);
  506|      1|        assert!(inst2.is_err());
  507|       |
  508|      1|        drop(inst1);
  509|       |        // Give time for handle to close
  510|      1|        std::thread::sleep(std::time::Duration::from_millis(100));
  511|      1|        let inst3 = SingleInstance::new(&name);
  512|      1|        assert!(inst3.is_ok());
  513|      1|    }
  514|       |}